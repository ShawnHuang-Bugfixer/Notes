---
date: 2025-05-12
aliases:
  - Redis网络模型
tags:
  - Redis网络模型
---
> [Redis 多线程网络模型](https://segmentfault.com/a/1190000039223696)

`Redis v4.0` 引入多线程处理异步任务，`Redis v6.0` 正式引入了多线程的网络 I/O 模型。

`Redis v6.0` 以前，Redis 的网络模型是单线程的 Reactor 模型。Redis 作为内存数据库，I/O 读写并不是性能瓶颈。假设引入多线程，线程间上下文切换会导致性能问题，多线程操作共享数据需要像 MySQL 一样引入同步机制。因此，`Redis v6.0` 前的网络模型使用的是单线程的 Reactor 模型。

# `Redis v6.0` 前的单线程事件循环

`Redis v6.0` 以前，Redis 采用单线程的 Reactor 模型，本质就是 **非阻塞 I/O** +  **I/O 多路复用**。

单线程利用 `select` `epoll` 等多路复用机制，循环的监听事件（如客户端连接、读写请求），并处理事件。

![[attachments/Pasted image 20250512101232.png]]

# `Redis v6.0` 后多线程网络模型

![[attachments/Pasted image 20250512103053.png]]

`Redis v6.0` 后，引入了非标准的 Multi-Reactors 多线程网络模型，主线程将客户端连接分配给 I/O 线程，I/O 线程负责命令读取，命令解析，当主线程和 I/O 线程都完成了读取任务，主线程执行所有命令，完成数据读取或者写入操作。然后主线程在事件循环中将连接分配给主线程和 I/O 线程，完成数据的写回操作。

**I/O 线程仅仅是读取和解析客户端命令而不会真正去执行命令，客户端命令的执行最终还是要在主线程上完成**。

在标准的 Multi-Reactors/Master-Workers 模式下，Sub Reactors/Workers 会完成 `网络读 -> 数据解析 -> 命令执行 -> 网络写` 整套流程，Main Reactor/Master 只负责分派任务，而在 Redis 的多线程方案中，I/O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，却没有真正去执行命令，所有客户端命令最后还需要回到主线程去执行，每次主线程都必须在分配完任务之后忙轮询等待所有 I/O 线程完成任务之后才能继续执行其他逻辑。

由主线程执行指令，避免了多线程并发执行指令导致的并发问题。