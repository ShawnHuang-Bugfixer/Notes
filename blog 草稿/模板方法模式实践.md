# 模板方法模式
模板方法模式是一种**行为型设计模式**。抽象出一个统一的流程（模板方法），其中某些具体的可变实现细节由子类重写。
![[attachments/Pasted image 20250901164554.png]]
模板类中将抽象方法或可被覆盖的方法声明为 `protected`，外部调用者不能随意调用这些方法，避免破坏整体流程，子类可以实现或覆盖这些方法，实现流程中差异化逻辑。

## 图片上传模板
图片上传到 COS 对象存储的步骤较为统一，为了同时支持文件上传和图片上传两种方式，可以将统一的上传流程抽象为一个模板，而校验文件等具体实现由子类实现。

模板类定义了图片上传的统一流程，包括文件校验、获取文件名、写入临时文件、上传到 COS 对象存储以及封装返回结果。

```Java
@Slf4j  
public abstract class PictureUploadTemplate<T> {
	public final UploadPictureResult uploadPicture(T resourceSource, String uploadPathPrefix);
	protected abstract String validatePicture(T resourceSource);
	protected abstract String getOriginalFilename(T resourceSource, String suffix);
	protected abstract void writeToTempFile(T resourceSource, File file);
}
```

子类实现抽象方法：

```Java
@Service  
public class FilePictureUpload extends PictureUploadTemplate<MultipartFile> {  
    @Override  
    protected String validatePicture(MultipartFile multipartFile) {  
        ThrowUtils.throwIf(multipartFile == null, ErrorCode.PARAMS_ERROR, "文件不能为空！");  
        final long SINGLE_PICTURE_MAX_SIZE = 8 * 1024 * 1024L;  
        ThrowUtils.throwIf(multipartFile.getSize() > SINGLE_PICTURE_MAX_SIZE, ErrorCode.PARAMS_ERROR, "文件大小不能超过8MB！");  
        final List<String> ALLOW_FORMAT_LIST = Arrays.asList("jpeg", "jpg", "png", "webp");  
        String fileSuffix = FileUtil.getSuffix(multipartFile.getOriginalFilename());  
        ThrowUtils.throwIf(!ALLOW_FORMAT_LIST.contains(fileSuffix), ErrorCode.PARAMS_ERROR, "文件类型错误！");  
        return fileSuffix;  
    }  
  
    @Override  
    protected String getOriginalFilename(MultipartFile resourceSource, String suffix) {  
        String originalFilename = resourceSource.getOriginalFilename();  
        ThrowUtils.throwIf(StrUtil.isBlank(originalFilename), ErrorCode.PARAMS_ERROR, "文件名不能为空！");  
        ThrowUtils.throwIf(originalFilename.length() > 100, ErrorCode.PARAMS_ERROR, "文件名长度不能超过100个字符！");  
        return originalFilename;  
    }  
  
    @Override  
    protected void writeToTempFile(MultipartFile resourceSource, File file) {  
        try {  
            resourceSource.transferTo(file);  
        } catch (Exception e) {  
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "文件上传失败！");  
        }  
    }  
}
```

```Java
@Service  
public class URLPictureUpload extends PictureUploadTemplate<String>{  
    @Override  
    protected String validatePicture(String resourceSource) {  
        // 1. 校验资源地址  
        ThrowUtils.throwIf(StringUtils.isBlank(resourceSource), ErrorCode.PARAMS_ERROR, "资源地址不能为空！");  
        ThrowUtils.throwIf(!resourceSource.startsWith("http://") && !resourceSource.startsWith("https://"), ErrorCode.PARAMS_ERROR, "资源地址格式错误！");  
        try {  
            new URL(resourceSource);  
        } catch (MalformedURLException e) {  
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "资源地址格式错误！");  
        }  
        // 2. 校验资源类型  
        try (HttpResponse response = HttpUtil.createRequest(Method.GET, resourceSource)  
                .setConnectionTimeout(1000)  
                .setReadTimeout(1000)  
                .header("Range", "bytes=0-0") // 只请求第一个字节，避免下载完整文件  
                .execute()) {  
            if (response.getStatus() != HttpStatus.HTTP_OK &&  
                    response.getStatus() != HttpStatus.HTTP_PARTIAL) {  
                throw new BusinessException(ErrorCode.PARAMS_ERROR, "不支持 Head 请求或资源地址错误!");  
            }  
            String contentType = response.header("Content-Type");  
            if (StringUtils.isBlank(contentType) || !contentType.startsWith("image/")) {  
                throw new BusinessException(ErrorCode.PARAMS_ERROR, "文件类型错误！");  
            }  
            final List<String> ALLOW_CONTENT_TYPES = Arrays.asList("image/jpeg", "image/jpg", "image/png", "image/webp");  
            ThrowUtils.throwIf(!ALLOW_CONTENT_TYPES.contains(contentType), ErrorCode.PARAMS_ERROR, "文件类型错误！");  
            // 3. 校验文件大小  
            ThrowUtils.throwIf(response.contentLength() > 1024 * 1024 * 8, ErrorCode.PARAMS_ERROR, "文件大小不能超过 8MB！");  
            return contentType.substring(contentType.indexOf("/") + 1);  
        } catch (RuntimeException e) {  
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "资源连接超时");  
        }  
    }  
  
    @Override  
    protected String getOriginalFilename(String resourceSource, String suffix) {  
        String fileName = FileUtil.mainName(resourceSource);  
        int maxLen = 128 - suffix.length() - 1;  
        if (fileName.length() >= maxLen) {  
            fileName = fileName.substring(0, maxLen);  
        }  
        return fileName + "." + suffix;  
    }  
  
    @Override  
    protected void writeToTempFile(String resourceSource, File file) {  
        HttpUtil.downloadFile(resourceSource, file);  
    }  
}
```
