现在需要设计一个抢券提醒的服务，用户可以预约抢券时间，用户预约后，在优惠券开抢前一个小时系统通过用户设定的方式比如短信、app、邮件等方式通知用户。预约时间段规定了只能是抢券前 1 h，且以 5 min 为间隔，比如提前 5
 min 、10 min 或者 15 min 通知用户即将开始抢券。

# 编码存储通知时段和通知方式
按照上述要求，1h 以 5 min 为间隔可以划分为 12 个时间段，并且支持 3 中通知方式，可以使用 3 * 12 个比特标识表示通知方式和通知时间段。为了拓展通知方式，直接使用 64 bit位标志通知方式和通知时间段。接下来介绍如何对通知方式和通知时间段编码。按照以下编码方式，64 bit 最多可以表示 5 种不同的通知方式。

1. **每种通知方式编码**
	短信：0
	邮件：1
	app：2
	...
2. **12 bit 表示时间段**
	从低位到高位分别表示 5、10、15 ... 60 等时间段，例如
	`0000 0000 1001` 表示在 5 min 和 20 min 通知。

“提前 10 min 使用短信通知，提前 20 min 使用邮件通知” 编码过程如下：
1. 先计算 10 min 对应的时段编码，将 1 左移 2 位 `0000 0000 0010` 
2. 然后根据通知方式将时段编码使用 '|' 运算整合到最终编码中，即将`0000 0000 0010` 左移 12 * 0 加入最终编码

```bit
...  0000 0000 0000 0000 0000 0000 // 最终编码
或操作
...  0000 0000 0000 0000 0000 0010 // 时段编码
---
...  0000 0000 0000 0000 0000 0010 // 最终编码
```

同样的计算 20 min 对应的时段编码然后左移 12 * 1 位，加入到最终编码。

```bit
...  0000 0000 0000 0000 0000 0010 // 最终编码
或操作
...  0000 0000 0010 0000 0000 0000 // 时段编码
---
...  0000 0000 0010 0000 0000 0010 // 最终编码
```

解码就是从低位到高位的逆过程，不再展示。

```Java
// 编码
public static Long calculateBitMap(Integer remindTime, CouponRemindTypeEnum couponRemindTypeEnum) {  
    if (ObjectUtils.isNull(couponRemindTypeEnum)) throw new ClientException("通知类型非法！");  
    int type = couponRemindTypeEnum.getType();  
    if (remindTime > TIME_INTERVAL * NEXT_TYPE_BITS) {  
        throw new ClientException("预约提醒的时间不能早于开票前" + TIME_INTERVAL * NEXT_TYPE_BITS + "分钟");  
    }  
    return 1L << (type * NEXT_TYPE_BITS + Math.max(0, remindTime / TIME_INTERVAL - 1));  
}
```

```Java
// 解码过程
public static void fillRemindInformation(CouponTemplateRemindQueryRespDTO resp, Long information) {  
    List<Date> dateList = new ArrayList<>();  
    List<String> remindType = new ArrayList<>();  
    Date validStartTime = resp.getValidStartTime();  
    for (int i = NEXT_TYPE_BITS - 1; i >= 0; i--) {  
        // 按时间节点倒叙遍历，即离开抢时间最久，离现在最近  
        for (int j = 0; j < CouponRemindTypeEnum.values().length; j++) {  
            // 对于每个时间节点，遍历所有类型  
            if (((information >> (j * NEXT_TYPE_BITS + i)) & 1) == 1) {  
                // 该时间节点的该提醒类型用户有预约  
                Date date = DateUtil.offsetMinute(validStartTime, -((i + 1) * TIME_INTERVAL));  
                dateList.add(date);  
                remindType.add(CouponRemindTypeEnum.getDescribeByType(j));  
            }  
        }  
    }  
    resp.setRemindTime(dateList);  
    resp.setRemindType(remindType);  
}
```

# 通知服务设计
抢券的预约通知明显涉及到延时通知操作，在预约通知阶段就涉及到如何实现提前通知功能和如何高效处理通知两个问题。既然有预约操作就有取消预约操作，那又涉及到如何高效的取消预约通知。

## 预约通知
首先来解决如何实现提前通知效果。本质就是用户点击预约通知后，等待一段时间后系统向用户发起通知，那么就可以利用到延时消息。

再来看如何高效通知，通知服务一般是一个高耗时的 IO 密集型任务，消息队列消费者处理消息时间应该尽量短，因此引入线程池异步调用通知服务。

现在就有了预约通知的大概流程。用户点击预约按钮后，将预约信息编码存储到数据库，发送延时消息，消费者通过线程池调用消息推送服务。

```Java
// 发送延时消息
 @Override  
    @Transactional    public void createCouponRemind(CouponTemplateRemindCreateReqDTO requestParam) {  
        // 1. 查询优惠券  
        CouponTemplateQueryRespDTO couponTemplate = couponTemplateService  
                .findCouponTemplate(new CouponTemplateQueryReqDTO(requestParam.getShopNumber(), requestParam.getCouponTemplateId()));  
  
//        // 为了测试方便注释掉该限制  
//        if (couponTemplate.getValidStartTime().before(new Date())) {  
//            throw new ClientException("无法预约已开始领取的优惠券");  
//        }  
  
        // 2. 查询用户提醒信息  
        LambdaQueryWrapper<CouponTemplateRemindDO> queryWrapper = Wrappers.lambdaQuery(CouponTemplateRemindDO.class)  
                .eq(CouponTemplateRemindDO::getUserId, UserContext.getUserId())  
                .eq(CouponTemplateRemindDO::getCouponTemplateId, requestParam.getCouponTemplateId());  
        CouponTemplateRemindDO couponTemplateRemindDO = couponTemplateRemindMapper.selectOne(queryWrapper);  
        CouponRemindTypeEnum remindTypeEnum = CouponRemindTypeEnum.getByType(requestParam.getType());  
        // 未设置抢券通知  
        if (couponTemplateRemindDO == null) {  
            couponTemplateRemindDO = BeanUtil.toBean(requestParam, CouponTemplateRemindDO.class);  
            couponTemplateRemindDO.setStartTime(couponTemplate.getValidStartTime());  
            // 记录通知类型以及通知时间  
            couponTemplateRemindDO.setInformation(CouponTemplateRemindUtil.calculateBitMap(requestParam.getRemindTime(), remindTypeEnum));  
            couponTemplateRemindDO.setUserId(Long.parseLong(UserContext.getUserId()));  
            couponTemplateRemindMapper.insert(couponTemplateRemindDO);  
        } else {  
            // 已经设置了抢券通知  
            Long information = couponTemplateRemindDO.getInformation();  
            Long newRemindInfo = CouponTemplateRemindUtil.calculateBitMap(requestParam.getRemindTime(), remindTypeEnum);  
            if (CouponTemplateRemindUtil.containsRemind(information, newRemindInfo)) {  
                throw new ClientException("以为该时间段创建了提醒！");  
            }  
            couponTemplateRemindDO.setInformation(CouponTemplateRemindUtil.mergeReminds(information, newRemindInfo));  
            couponTemplateRemindMapper.update(couponTemplateRemindDO, queryWrapper);  
        }  
  
        // 3. 发送预约提醒抢购优惠券延时消息  
        CouponTemplateRemindDelayEvent couponRemindDelayEvent = CouponTemplateRemindDelayEvent.builder()  
                .couponTemplateId(couponTemplate.getId())  
                .userId(UserContext.getUserId())  
                .contact(UserContext.getUserId())  
                .shopNumber(couponTemplate.getShopNumber())  
                .type(requestParam.getType())  
                .remindTime(requestParam.getRemindTime())  
                .startTime(couponTemplate.getValidStartTime())  
                .delayTime(DateUtil.offsetMinute(couponTemplate.getValidStartTime(), -requestParam.getRemindTime()).getTime())  
                .build();  
        log.info("[生产者] 设置抢券时间提醒。发送消息：{}", couponRemindDelayEvent);  
        couponRemindDelayProducer.sendMessage(couponRemindDelayEvent);  
  
        // 4. 更新数据库后删除预约信息缓存，保障数据一致性。  
        stringRedisTemplate.delete(String.format(EngineRedisConstant.USER_COUPON_TEMPLATE_REMIND_INFORMATION, UserContext.getUserId()));  
    }
```

```Java
// 处理延时消息
@Component  
@RequiredArgsConstructor  
@RocketMQMessageListener(  
        topic = "one-coupon_engine-service_coupon-remind_topic${unique-name:}",  
        consumerGroup = "one-coupon_engine-service_coupon-remind_cg${unique-name:}"  
)  
@Slf4j(topic = "CouponTemplateRemindDelayConsumer")  
public class CouponTemplateRemindDelayConsumer implements RocketMQListener<MessageWrapper<CouponTemplateRemindDelayEvent>> {  
  
    private final CouponTemplateRemindExecutor couponTemplateRemindExecutor;  
    private final CouponTemplateRemindService couponTemplateRemindService;  
  
    @Override  
    public void onMessage(MessageWrapper<CouponTemplateRemindDelayEvent> messageWrapper) {  
        log.info("[消费者] 提醒用户抢券 - 执行消费逻辑，消息体：{}", JSON.toJSONString(messageWrapper));  
        CouponTemplateRemindDelayEvent event = messageWrapper.getMessage();  
        CouponTemplateRemindDTO couponTemplateRemindDTO = BeanUtil.toBean(event, CouponTemplateRemindDTO.class);  
  
        if (couponTemplateRemindService.isCanceledRemind(couponTemplateRemindDTO)) {  
            log.info("[消费者] 提醒用户抢券，{} 该提醒已被取消，终止执行消费逻辑。", couponTemplateRemindDTO);  
            return;  
        };  
        // 配置线程池处理 IO 密集型任务，避免阻塞消费者线程。  
        couponTemplateRemindExecutor.executeRemindCouponTemplate(couponTemplateRemindDTO);  
    }  
}
```

```Java
// 线程池配置，并使用 CallerRunsPolicy 策略
@Component  
@RequiredArgsConstructor  
@Slf4j  
public class CouponTemplateRemindExecutor {  
  
    private final SendEmailRemindCouponTemplate sendEmailRemindCouponTemplate;  
    private final SendAppMessageRemindCouponTemplate sendAppMessageRemindCouponTemplate;  
  
    private final RedissonClient redissonClient;  
    private final StringRedisTemplate stringRedisTemplate;  
  
    // 提醒用户属于 IO 密集型任务  
    private final ExecutorService executorService = new ThreadPoolExecutor(  
            Runtime.getRuntime().availableProcessors() << 1,  
            Runtime.getRuntime().availableProcessors() << 2,  
            60,  
            TimeUnit.SECONDS,  
            new SynchronousQueue<>(),  
            new ThreadPoolExecutor.CallerRunsPolicy()  
    );  
  
    /**  
     * 执行提醒  
     *  
     * @param couponTemplateRemindDTO 用户预约提醒请求信息  
     */  
    public void executeRemindCouponTemplate(CouponTemplateRemindDTO couponTemplateRemindDTO) {  
        // 假设刚把消息提交到线程池，突然应用宕机了，我们通过延迟队列进行兜底 Refresh        RBlockingDeque<String> blockingDeque = redissonClient.getBlockingDeque(EngineRedisConstant.REDIS_BLOCKING_DEQUE);  
        RDelayedQueue<String> delayedQueue = redissonClient.getDelayedQueue(blockingDeque);  
        String key = String.format(EngineRedisConstant.COUPON_REMIND_CHECK_KEY, couponTemplateRemindDTO.getUserId(), couponTemplateRemindDTO.getCouponTemplateId(), couponTemplateRemindDTO.getRemindTime(), couponTemplateRemindDTO.getType());  
        stringRedisTemplate.opsForValue().set(key, JSON.toJSONString(couponTemplateRemindDTO));  
        delayedQueue.offer(key, 10, TimeUnit.SECONDS);  
  
        executorService.execute(() -> {  
            // 用户没取消预约，则发出提醒  
            // 向用户发起消息提醒  
            switch (Objects.requireNonNull(CouponRemindTypeEnum.getByType(couponTemplateRemindDTO.getType()))) {  
                case APP -> sendAppMessageRemindCouponTemplate.remind(couponTemplateRemindDTO);  
                case EMAIL -> sendEmailRemindCouponTemplate.remind(couponTemplateRemindDTO);  
                default -> {  
  
                }  
            }  
  
            try {  
                stringRedisTemplate.delete(key);  
                delayedQueue.remove(key);  
            } catch (Exception e) {  
                log.warn("提醒任务删除 Redis Key / 延迟队列失败，key={}", key, e);  
            }  
  
        });  
    }  
  
    @Slf4j  
    @Component    @RequiredArgsConstructor    static class RefreshCouponRemindDelayQueueRunner implements CommandLineRunner {  
  
        private final CouponTemplateRemindDelayProducer couponRemindProducer;  
        private final RedissonClient redissonClient;  
        private final StringRedisTemplate stringRedisTemplate;  
  
        @Override  
        public void run(String... args) {  
            Executors.newSingleThreadExecutor(  
                runnable -> {  
                    Thread thread = new Thread(runnable);  
                    thread.setName("delay_coupon-remind_consumer");  
                    thread.setDaemon(Boolean.TRUE);  
                    return thread;  
                }).execute(() -> {  
                    RBlockingDeque<String> blockingDeque = redissonClient.getBlockingDeque(EngineRedisConstant.REDIS_BLOCKING_DEQUE);  
                    for (; ; ) {  
                        try {  
                            // 获取延迟队列待消费 Key                            String key = blockingDeque.take();  
                            if (Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))) {  
                                log.info("检查用户发送的通知消息Key：{} 未消费完成，开启重新投递", key);  
  
                                // Redis 中还存在该 Key，说明任务没被消费完，则可能是消费机器宕机了，重新投递消息  
                                CouponTemplateRemindDelayEvent couponTemplateRemindDelayEvent = JSONUtil.toBean(stringRedisTemplate.opsForValue().get(key), CouponTemplateRemindDelayEvent.class);  
                                couponRemindProducer.sendMessage(couponTemplateRemindDelayEvent);  
  
                                // 提醒用户后删除 Key                                stringRedisTemplate.delete(key);  
                            }  
                        } catch (Throwable ignore) {  
                        }  
                    }  
                });  
        }  
    }  
}
```

## 取消预约
上述预约提醒流程中使用延时消息实现预约功能，那么如何实现取消功能呢？对于已经发送出的消息，一般无法修改，因此需要在消费者测处理取消预约逻辑。其实也非常简单，只需要在调用通知服务前是检查数据库否有预约记录即可。

由于涉及到在多个时间段使用多种方式通知，因此在取消预约服务时，涉及到位操作，比如移除某个时间段某种类型通知，仅需计算对应编码值然后和数据库中的编码值执行异或操作即可移除。

```Java
/**  
 * 预约抢券时间工具类  
 */  
public class CouponTemplateRemindUtil {  
  
    private static final int NEXT_TYPE_BITS = 12;  
  
    private static final int TIME_INTERVAL = 5;  
  
    /**  
     * 使用位图保存消息通知类型以及通知时间。  
     * 1. 仅支持 1 h 内的抢券预约。以 5 min 为时间间隔将 1h 划分为 12 段，利用 12 bit 位表示 1 个小时。  
     * 2. 将 long 64 bit 切分为[0,4]共5段，每段 12 位，共占 60 个 bit，从低位到高位每段可表示一种通知类型。  
     *  
     * @return 通知类型以及通知时间 bitmap 表示  
     */  
    public static Long calculateBitMap(Integer remindTime, CouponRemindTypeEnum couponRemindTypeEnum) {  
        if (ObjectUtils.isNull(couponRemindTypeEnum)) throw new ClientException("通知类型非法！");  
        int type = couponRemindTypeEnum.getType();  
        if (remindTime > TIME_INTERVAL * NEXT_TYPE_BITS) {  
            throw new ClientException("预约提醒的时间不能早于开票前" + TIME_INTERVAL * NEXT_TYPE_BITS + "分钟");  
        }  
        return 1L << (type * NEXT_TYPE_BITS + Math.max(0, remindTime / TIME_INTERVAL - 1));  
    }  
  
    /**  
     * 从合并后的 information 中解析出发送类型以及提醒时间，并给 resp 赋值。  
     *  
     * @param resp 返回封装类型和提醒时间后的对象。  
     * @param information long 类型，封装了推送类型和推送时间。  
     */  
    public static void fillRemindInformation(CouponTemplateRemindQueryRespDTO resp, Long information) {  
        List<Date> dateList = new ArrayList<>();  
        List<String> remindType = new ArrayList<>();  
        Date validStartTime = resp.getValidStartTime();  
        for (int i = NEXT_TYPE_BITS - 1; i >= 0; i--) {  
            // 按时间节点倒叙遍历，即离开抢时间最久，离现在最近  
            for (int j = 0; j < CouponRemindTypeEnum.values().length; j++) {  
                // 对于每个时间节点，遍历所有类型  
                if (((information >> (j * NEXT_TYPE_BITS + i)) & 1) == 1) {  
                    // 该时间节点的该提醒类型用户有预约  
                    Date date = DateUtil.offsetMinute(validStartTime, -((i + 1) * TIME_INTERVAL));  
                    dateList.add(date);  
                    remindType.add(CouponRemindTypeEnum.getDescribeByType(j));  
                }  
            }  
        }  
        resp.setRemindTime(dateList);  
        resp.setRemindType(remindType);  
    }  
  
    /**  
     * 合并两个提醒 bitmap（按位或）  
     */  
    public static Long mergeReminds(Long bitmap1, Long bitmap2) {  
        return (bitmap1 == null ? 0L : bitmap1) | (bitmap2 == null ? 0L : bitmap2);  
    }  
  
    /**  
     * 判断是否包含某个提醒  
     */  
    public static boolean containsRemind(Long bitmap, Integer remindTime, CouponRemindTypeEnum type) {  
        Long flag = calculateBitMap(remindTime, type);  
        return (bitmap & flag) != 0L;  
    }  
  
    public static boolean containsRemind(Long source, Long target) {  
        return (source & target) != 0L;  
    }  
  
    public static Long removeRemind (Long source, Long target) {  
        source ^= target;  
        return source;  
    }  
}
```

当且仅当不存在任何形式的预约时，才认为用户取消了所有预约。消费者调用通知服务时根据数据库是否有预约记录判断是否调用通知服务。

还可以进行优化，整合布隆过滤器，将完全取消预约的信息添加到布隆过滤器，在消费者处利用布隆过滤器减少数据库访问次数。

```Java
// 取消预约
@Override  
@Transactional  
public void cancelCouponRemind(CouponTemplateRemindCancelReqDTO requestParam) {  
    // 1. 合法性校验  
  
    // 检查优惠券是否已经开始抢购  
    CouponTemplateQueryRespDTO couponTemplate = couponTemplateService  
            .findCouponTemplate(new CouponTemplateQueryReqDTO(requestParam.getShopNumber(), requestParam.getCouponTemplateId()));  
    if (couponTemplate.getValidStartTime().before(new Date())) {  
        throw new ClientException("无法取消已开始领取的优惠券预约");  
    }  
  
    // 检查优惠券模板是否存在  
    LambdaQueryWrapper<CouponTemplateRemindDO> queryWrapper = Wrappers.lambdaQuery(CouponTemplateRemindDO.class)  
            .eq(CouponTemplateRemindDO::getUserId, UserContext.getUserId())  
            .eq(CouponTemplateRemindDO::getCouponTemplateId, requestParam.getCouponTemplateId());  
    CouponTemplateRemindDO couponTemplateRemindDO = couponTemplateRemindMapper.selectOne(queryWrapper);  
    if (couponTemplateRemindDO == null) {  
        throw new ClientException("优惠券模板预约信息不存在");  
    }  
  
    // 2. 判断是否包含取消请求中携带的预约类型和时间  
    Long bitMap = CouponTemplateRemindUtil.calculateBitMap(requestParam.getRemindTime(), CouponRemindTypeEnum.getByType(requestParam.getType()));  
    if (!CouponTemplateRemindUtil.containsRemind(bitMap, couponTemplateRemindDO.getInformation())) {  
        throw new ClientException("您没有预约该时间点的提醒");  
    }  
  
    // 包含预约类型以及预约时间  
    queryWrapper.eq(CouponTemplateRemindDO::getInformation, couponTemplateRemindDO.getInformation());  
    if (CouponTemplateRemindUtil.removeRemind(bitMap, couponTemplateRemindDO.getInformation()).equals(0L)) {  
        // 如果新 BitMap 信息是 0，说明已经没有预约提醒了，可以直接删除  
        if (couponTemplateRemindMapper.delete(queryWrapper) == 0) {  
            // MySQL 乐观锁进行删除，如果删除失败，说明用户可能同时正在进行删除、新增提醒操作  
            throw new ClientException("取消提醒失败，请刷新页面后重试");  
        }  
    } else {  
        // 虽然删除了这个预约提醒，但还有其它提醒，那就更新数据库  
        couponTemplateRemindDO.setInformation(bitMap);  
        if (couponTemplateRemindMapper.update(couponTemplateRemindDO, queryWrapper) == 0) {  
            // MySQL 乐观锁进行更新，如果更新失败，说明用户可能同时正在进行删除、新增提醒操作  
            throw new ClientException("取消提醒失败，请刷新页面后重试");  
        }  
    }  
  
    // 取消提醒这个信息添加到布隆过滤器中  
    cancelRemindBloomFilter.add(String.valueOf(Objects.hash(requestParam.getCouponTemplateId(), UserContext.getUserId(), requestParam.getRemindTime(), requestParam.getType())));  
  
    // 删除用户预约提醒的缓存信息，通过更新数据库删除缓存策略保障数据库和缓存一致性  
    stringRedisTemplate.delete(String.format(EngineRedisConstant.USER_COUPON_TEMPLATE_REMIND_INFORMATION, UserContext.getUserId()));  
}
```

```Java
// 消费者新增校验取消预约逻辑
@Override  
public boolean isCanceledRemind (CouponTemplateRemindDTO requestParam) {  
    if (!cancelRemindBloomFilter.contains(String.valueOf(Objects.hash(requestParam.getCouponTemplateId(), requestParam.getUserId(), requestParam.getRemindTime(), requestParam.getType())))) {  
        // 布隆过滤器中不存在，说明没取消提醒，此时已经能挡下大部分请求  
        return false;  
    }  
  
    // 对于少部分的“取消了预约”，可能是误判，此时需要去数据库中查找  
    LambdaQueryWrapper<CouponTemplateRemindDO> queryWrapper = Wrappers.lambdaQuery(CouponTemplateRemindDO.class)  
            .eq(CouponTemplateRemindDO::getUserId, requestParam.getUserId())  
            .eq(CouponTemplateRemindDO::getCouponTemplateId, requestParam.getCouponTemplateId());  
    CouponTemplateRemindDO couponTemplateRemindDO = couponTemplateRemindMapper.selectOne(queryWrapper);  
    if (couponTemplateRemindDO == null) {  
        // 数据库中没该条预约提醒，说明被取消  
        return true;  
    }  
  
    // 即使存在数据，也要检查该类型的该时间点是否有提醒  
    Long information = couponTemplateRemindDO.getInformation();  
    Long bitMap = CouponTemplateRemindUtil.calculateBitMap(requestParam.getRemindTime(), CouponRemindTypeEnum.getByType(requestParam.getType()));  
  
    return !CouponTemplateRemindUtil.containsRemind(information, bitMap);  
}
```