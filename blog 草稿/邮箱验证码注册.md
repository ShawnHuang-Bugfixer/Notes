最简单原始的注册方式就是直接暴露注册接口，客户端直接调用该接口即可注册成功，但是该方案有严重的漏洞。可以直接编写脚本调用服务端注册接口，注册大量虚假用户，当量达到一定限制后，很可能瘫痪数据库，导致系统崩溃。因此，必须限制注册接口。

最常见的限制注册的方式就是验证码注册，包含短信验证码和邮箱验证码等方式，短信验证码需要付费开通，因此采用邮箱验证码方案。

开通邮箱服务见：[如何开通邮箱服务？](https://blog.csdn.net/qq_42263280/article/details/129584017)

# 发送验证码接口设计
搭建完毕邮件发送服务并测试后，可以得出发送一封邮件耗时极长，甚至可能达到 5s 以上，如果发送接口同步调用邮件发送服务，那么可以预见，当并发出现大量发送验证码请求时会导致系统瘫痪。因此使用消息队列解耦生成验证码和发送验证码，以此提高接口响应速度。

# 一次性 Token 保护发送验证码接口
搭建出基础邮箱发送邮件框架后，开始讨论如何构建可靠的邮箱注册服务。验证码注册的粗略流程可以概括为向邮箱发送验证码，客户端携带该验证码注册。既然涉及获取验证码，服务端自然需要暴露一个新的获取验证码接口。那又如何保障该接口不被脚本轻易调用呢？

要保护发送验证码接口不轻易地被脚本调用，就需要额外地保护机制。我的做法是一次性 token 校验。客户端请求发送验证码接口时必须携带一次性 token，否则拒绝发送验证码。显然又带来一个问题，如何获取一次性 token？由此便引入了滑块验证，客户端请求发送验证码接口时首先弹出滑块验证码组件，用户拖动滑块通过验证，客户端发送滑块轨迹信息到后端，后端分析滑块轨迹，通过人机验证后发送一次性 token，此时客户端可以携带一次性 token 请求发送验证码接口。

```Java
@Target(ElementType.METHOD)  
@Retention(RetentionPolicy.RUNTIME)  
public @interface OnceTokenRequired {  
    /**  
     * 是否需要登录才能验证 token。默认 true。  
     */  
    boolean needLogin() default true;  
}

@Aspect  
@Component  
@Slf4j  
public class OnceTokenAspect {  
  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
  
    @Resource  
    private HttpServletRequest request;  
  
    @Resource  
    private HttpServletResponse response;  
  
    @Resource  
    private TokenService tokenService;  
  
    @Resource  
    private CookiesProperties cookiesProperties;  
  
    private String onceTokenName;  
  
    private String path;  
  
    private String domain;  
  
    @PostConstruct  
    public void init() {  
        CookiesProperties.CookieInfo refreshTokenInfo = cookiesProperties.getCookieConfigs().get("onceToken");  
        Cookie onceCookie = CookieUtil.buildCookie(refreshTokenInfo, null);  
        onceTokenName = onceCookie.getName();  
        path = onceCookie.getPath();  
        domain = onceCookie.getDomain();  
    }  
  
    @Around("@annotation(com.xin.picturebackend.annotation.OnceTokenRequired)")  
    public Object validateOnceToken(ProceedingJoinPoint joinPoint) throws Throwable {  
        // 1. 获取注解信息  
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();  
        Method method = signature.getMethod();  
        OnceTokenRequired annotation = method.getAnnotation(OnceTokenRequired.class);  
        boolean needLogin = annotation.needLogin();  
  
        // 2. 获取 token（来自 cookie）  
        String token = getOnceToken();  
  
        // 3. 获取 Redis key        String redisKey;  
        long userId = -1;  
  
        if (needLogin) {  
            // 登录情况下，使用登录用户 ID            userId = StpUtil.getLoginIdAsLong();  
            redisKey = RedisKeyConstant.ONCE_TOKEN_LOGIN_PREFIX + userId;  
        } else {  
            // 未登录情况下，token 直接作为 key            redisKey = RedisKeyConstant.ONCE_TOKEN_NOT_LOGIN_PREFIX + token;  
        }  
  
        // 4. 校验 token 是否一致  
        String storedToken = stringRedisTemplate.opsForValue().get(redisKey);  
        if (storedToken == null || !storedToken.equals(token)) {  
            // 记录当前请求 IP 和 token，利于安全审计  
            log.warn("非法或重复 token 尝试, IP={}, token={}", request.getRemoteAddr(), token);  
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "Token 无效或已失效");  
        }  
  
        // 5. 删除 Redis token        stringRedisTemplate.delete(redisKey);  
        log.debug("删除 Redis 中 token, key {}", redisKey);  
  
        // 6. 删除 Cookie        tokenService.removeCookie(response, onceTokenName, path, domain);  
        log.debug("删除 cookie {}", onceTokenName);  
  
        // 7. 放行请求  
        return joinPoint.proceed();  
    }  
  
    private String getOnceToken() {  
        Cookie[] cookies = request.getCookies();  
        if (cookies == null) {  
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "未携带任何 cookie");  
        }  
  
        String token = null;  
        for (Cookie cookie : cookies) {  
            if (onceTokenName.equals(cookie.getName())) {  
                token = cookie.getValue();  
                break;  
            }  
        }  
  
        if (token == null) {  
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "未携带 onceToken");  
        }  
        return token;  
    }  
}
```

```Java
@RestController  
@RequestMapping("/email")  
public class EmailCodeController {  
  
    @Resource  
    private EmailCodeService emailCodeService;  
  
    @Resource  
    private TokenService tokenService;  
  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
  
    @GetMapping("/sendCode")  
    @OnceTokenRequired(needLogin = false)  
    public BaseResponse<Boolean> sendEmailCode(@RequestParam("email") String email) {  
        return ResultUtils.success(emailCodeService.sendCode(email));  
    }  
  
    @GetMapping("/sliderToken")  
    public BaseResponse<Boolean> getSliderToken(HttpServletResponse response) {  
        // fixme 可以直接请求该接口拿到 token，仍然存在脚本攻击问题。  
        //  优化方案：滑块验证码通过后，请求携带滑块行为轨迹信息，后端分析该信息通过后才发放 token，而不是直接发送 token。  
        String token = UUID.randomUUID().toString();  
        String redisKey = RedisKeyConstant.ONCE_TOKEN_NOT_LOGIN_PREFIX + token;  
        stringRedisTemplate.opsForValue().set(redisKey, token, Duration.ofMinutes(1));  
  
        // 设置 cookie        tokenService.writeTokenToCookies(response, token, "onceToken");  
        return ResultUtils.success(true);  
    }  
}
```
# 发送验证码接口频率限制和邮箱发送频率限制
为了避免用户频繁点击发送验证码按钮，除了前端做限制外，后端也要限制，因为后端不信任一切前端校验。利用 Redis TTL 做发送验证码频率限制，同时 Redis 存储一段时间内特定邮箱发送验证码的次数，当该次数超出阈值，限制该邮箱注册。

```Java
@Service  
@Slf4j  
public class EmailCodeServiceImpl implements EmailCodeService {  
  
    @Resource  
    private RedisTemplate<String, String> redisTemplate;  
  
    @Resource  
    private RabbitTemplate rabbitTemplate;  
  
    @Resource  
    private UserService userService;  
  
    @Resource  
    private EmailCodeProperties emailCodeProperties;  
  
    @Override  
    public boolean sendCode(String email) {  
        int maxSends = emailCodeProperties.getMaxSendsPerPeriod();  
        int limitExpire = emailCodeProperties.getSendLimitExpireMinutes();  
        int length = emailCodeProperties.getCodeLength();  
        int cooldown = emailCodeProperties.getSendCooldownSeconds();  
        int ttl = emailCodeProperties.getCodeExpireMinutes();  
  
        // 1. 校验邮箱格式  
        if (!EmailUtil.isValidEmail(email)) {  
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "邮箱格式非法");  
        }  
  
        // 2. 校验是否已注册  
        if (userService.isEmailRegistered(email)) {  
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "该邮箱已注册");  
        }  
  
        // 3. 冷却限制（60s 内不可重复发送）  
        String cooldownKey =  RedisKeyConstant.EMAIL_SEND_COOLDOWN_KEY_PREFIX + email;  
        if (Boolean.TRUE.equals(redisTemplate.hasKey(cooldownKey))) {  
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "请勿频繁获取验证码");  
        }  
  
        // 4. 每 30 分钟内最多发送次数限制  
        String frequencyKey =  RedisKeyConstant.EMAIL_SEND_LIMIT_KEY_PREFIX + email;  
        Boolean hasFrequencyKey = redisTemplate.hasKey(frequencyKey);  
        Long sendCount = redisTemplate.opsForValue().increment(frequencyKey);  
        if (Boolean.FALSE.equals(hasFrequencyKey)) {  
            redisTemplate.expire(frequencyKey, Duration.ofMinutes(limitExpire));  
        }  
        if (sendCount != null && sendCount > maxSends) {  
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "验证码发送过于频繁");  
        }  
  
        // 5. 生成并缓存验证码（5 分钟有效）  
        String code = CodeUtil.generateCode(length);  
        String codeKey = RedisKeyConstant.EMAIL_CODE_KEY_PREFIX + email;  
        redisTemplate.opsForValue().set(codeKey, code, Duration.ofMinutes(ttl));  
  
        // 设置 60 秒冷却期  
        redisTemplate.opsForValue().set(cooldownKey, "1", Duration.ofSeconds(cooldown));  
  
        // 6. 投递到 MQ        EmailMessage emailMessage = new EmailMessage(email, code);  
        try {  
            rabbitTemplate.convertAndSend(MQConstants.EMAIL_CODE_EXCHANGE, MQConstants.ROUTING_EMAIL_CODE, emailMessage);  
            log.info("验证码消息已成功投递至 MQ，email={}，code={}", email, code);  
        } catch (Exception e) {  
            log.error("验证码发送消息投递 MQ 失败，email={}，code={}", email, code, e);  
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "验证码发送失败，请稍后再试");  
        }  
  
        return true;  
    }  
}
```
# 注册接口
客户端携带验证码请求和其他信息请求注册接口，后端比对验证 Redis 中的验证码，此时为了避免用户使用脚本穷举出验证码，还需要控制用户验证失败次数。同样的利用 Redis 实现，统计用户失败次数，如果一段时间内失败次数过多，直接暂时封禁改邮箱的注册流程。

```Java
@Override  
@Transactional  
public long userRegister(String userAccount, String userPassword, String checkPassword, String email, String code) {  
    // 1. 格式校验  
    checkRegistrationLegality(userAccount, userPassword, checkPassword, code, email);  
    String codeKey = RedisKeyConstant.EMAIL_CODE_KEY_PREFIX + email;  
    String failKey = RedisKeyConstant.EMAIL_CODE_FAIL_COUNT_PREFIX + email;  
  
    // 2. 验证码校验  
    validateCode(codeKey, failKey, email, code);  
  
    // 3. 用户注册入库  
    Long userId = createUser(userAccount, userPassword, email);  
  
    // 4. 清理 Redis 中验证码相关记录  
    redisTemplate.delete(Arrays.asList(codeKey, failKey,  
            RedisKeyConstant.EMAIL_SEND_COOLDOWN_KEY_PREFIX + email,  
            RedisKeyConstant.EMAIL_SEND_LIMIT_KEY_PREFIX + email));  
    return userId;  
}  
  
private void validateCode(String codeKey, String failKey, String email, String code) {  
    // 1. 获取验证码  
    String cachedCode = redisTemplate.opsForValue().get(codeKey);  
  
    // 1.1 校验失败次数  
    String failCountStr = redisTemplate.opsForValue().get(failKey);  
    int failCount = failCountStr != null ? Integer.parseInt(failCountStr) : 0;  
    if (failCount >= emailCodeProperties.getMaxValidateFailCount()) {  
        throw new BusinessException(ErrorCode.OPERATION_ERROR, "验证码错误次数过多，请稍后再试");  
    }  
  
    // 1.2 验证码不存在  
    if (cachedCode == null) {  
        throw new BusinessException(ErrorCode.OPERATION_ERROR, "验证码已过期或未发送");  
    }  
  
    // 1.3 验证码错误  
    if (!cachedCode.equals(code)) {  
        redisTemplate.opsForValue().increment(failKey);  
        //设置失败计数过期时间，如 30 分钟  
        redisTemplate.expire(failKey, Duration.ofMinutes(emailCodeProperties.getValidateFailCountExpireMinutes()));  
        throw new BusinessException(ErrorCode.OPERATION_ERROR, "验证码错误");  
    }  
}
```
