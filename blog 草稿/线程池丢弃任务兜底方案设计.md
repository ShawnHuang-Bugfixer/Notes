在高并发场景下，如果将耗时任务直接放入线程池执行，容易引发接口阻塞、线程池任务堆积甚至雪崩效应。为保障接口响应速度，通常会将线程池配置为“CPU 核数到 2×核数”的线程数，无缓冲队列（`SynchronousQueue`）和丢弃策略（`DiscardPolicy`），这样非关键任务会在高负载下被主动丢弃，避免阻塞主流程。然而，当某些任务具有关键性，不能因为丢弃策略而被忽略时，就需要额外设计兜底方案。

以解析并统计大规模 Excel 文件行为为例。通过 EasyExcel 解析百万级用户数据时，耗时通常达到数秒甚至更久。直接在调用线程中执行不仅拖慢接口响应，而且无法控制耗时上限，因此必须放入线程池异步执行。但线程池一旦拒绝执行，这类核心任务便可能丢失。为确保任务最终一定被执行，可引入延时阻塞队列作为兜底处理。

实现方式是：提交任务到线程池的同时，将任务副本写入 Redisson 的延时阻塞队列。延时设置为 20 秒，足以覆盖正常线程池执行完成的时间。当容器启动时，通过 Bean 生命周期启动一个单线程守护进程，从延时阻塞队列中循环获取到期任务。如果线程池执行失败或任务被丢弃，延时队列会触发兜底逻辑，再次执行任务。为避免重复执行，需要利用数据库记录或任务状态来确保幂等。

```Java
private final ExecutorService executorService = new ThreadPoolExecutor(
    Runtime.getRuntime().availableProcessors(),
    Runtime.getRuntime().availableProcessors() << 1,
    60, TimeUnit.SECONDS,
    new SynchronousQueue<>(),
    new ThreadPoolExecutor.DiscardPolicy()
);

JSONObject delayJsonObject = JSONObject.of("fileAddress", requestParam.getFileAddress(),
                                           "couponTaskId", couponTaskDO.getId());
executorService.execute(() -> refreshCouponTaskSendNum(delayJsonObject));

```

兜底策略通过 Redisson 延时队列实现：

```Java
RBlockingDeque<Object> blockingDeque = redissonClient.getBlockingDeque("COUPON_TASK_SEND_NUM_DELAY_QUEUE");
RDelayedQueue<Object> delayedQueue = redissonClient.getDelayedQueue(blockingDeque);
delayedQueue.offer(delayJsonObject, 20, TimeUnit.SECONDS);
```

在容器启动时，开启独立线程循环消费延时队列：

```Java
@Service
@RequiredArgsConstructor
class RefreshCouponTaskDelayQueueRunner implements CommandLineRunner {

    private final CouponTaskMapper couponTaskMapper;
    private final RedissonClient redissonClient;

    @Override
    public void run(String... args) {
        Executors.newSingleThreadExecutor(runnable -> {
            Thread thread = new Thread(runnable);
            thread.setName("delay_coupon-task_send-num_consumer");
            thread.setDaemon(true);
            return thread;
        }).execute(() -> {
            RBlockingDeque<JSONObject> blockingDeque =
                redissonClient.getBlockingDeque("COUPON_TASK_SEND_NUM_DELAY_QUEUE");
            for (;;) {
                try {
                    JSONObject delayJsonObject = blockingDeque.take();
                    if (delayJsonObject != null) {
                        CouponTaskDO couponTaskDO =
                            couponTaskMapper.selectById(delayJsonObject.getLong("couponTaskId"));
                        if (couponTaskDO.getSendNum() == null) {
                            refreshCouponTaskSendNum(delayJsonObject);
                        }
                    }
                } catch (Throwable ignored) {
                }
            }
        });
    }
}
```

这种“线程池 + 延时队列”双重保障机制能够兼顾接口响应速度和任务可靠性：线程池快速异步处理大部分请求，延时队列负责捕捉遗漏任务，保证最终一致性。核心在于任务的幂等设计，即重复触发时不会导致数据错乱。这一模式适用于各类需要保证最终执行的关键任务，例如数据同步、消息补偿或大规模批量操作。