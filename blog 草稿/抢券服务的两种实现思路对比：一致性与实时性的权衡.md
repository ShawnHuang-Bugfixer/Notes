在优惠券发放场景中，**库存极其敏感**，又需要承载高并发的领取操作。常见做法是利用 Redis + Lua 脚本完成原子校验和扣减，再通过消息队列异步落库，以保证高性能和可扩展性。  
在设计过程中，核心问题在于：**用户领取优惠券后，用户优惠券集合（我的优惠券列表）应该在什么时候写入 Redis？**

## 思路一：Redis 仅做库存与上限校验，用户领券集合由消费者写入

**流程：**
1. Lua 脚本在 Redis 中校验用户领取上限，并扣减库存。
2. 消费者异步落库，新增用户领券记录。
3. 落库成功后，同步写 Redis，向用户领券集合中新增记录。

**优点：**
- **逻辑简单**：Lua 脚本只做关键原子操作，降低复杂度和出错风险。
- **一致性更强**：数据库落库成功后再写缓存，避免 Redis 出现“幽灵券”。
- **容错容易**：如果数据库操作失败，Redis 用户集合不会被污染，不需要额外补偿。

**缺点：**
- **实时性不足**：用户领取后，需要等消费者写入 Redis 才能在“我的优惠券”中看到。若 MQ 堆积或延迟，用户会短时间“查不到券”。
- **依赖消息队列**：MQ 出现延迟，用户体验受影响。

## 思路二：Redis 提前写用户领券集合，数据库异步落库

**流程：**
1. Lua 脚本在 Redis 中完成校验、库存扣减，同时直接写入用户领券集合。
2. 消费者异步落库，新增用户领券记录。
**优点：**
- **实时性强**：用户领取后立即能在“我的优惠券”中看到，体验最佳。
- **对 MQ 延迟不敏感**：Redis 已经有数据，用户端几乎无感知。

**缺点：**
- **一致性风险大**：
    - 消费者落库失败，Redis 里可能存在“幽灵券”。
    - MQ 丢消息或数据库回滚时，需要复杂的补偿机制。
- **脚本复杂度高**：库存、上限、集合写入逻辑都要在 Lua 中完成，调试难度增加。

## 对比总结
- **思路一：数据库为主，Redis 为从**  
    优先保证一致性，稳健但牺牲一点实时性。适合 **金融级场景、库存强约束业务**。
- **思路二：Redis 为主，数据库为从**  
    优先保证用户体验，实时性极好，但需要复杂的补偿来兜底。适合 **营销导向、用户体验优先的业务**。

## 折中思路：双阶段写入
为了兼顾两者，可以采用“**轻量标记 + 转正**”机制：
1. Lua 脚本先写入一条 **pending 领取标记** 到用户领券集合。
2. 消费者落库成功后，将其转正为“已领取”。
3. 若落库失败，定时任务或 binlog 补偿机制清理 pending 数据。
这种方式既能让用户**即时看到券**，又能在最终一致性上有所保障，平衡了性能与体验。