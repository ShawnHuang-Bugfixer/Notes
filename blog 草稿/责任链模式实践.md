# 责任链模式
责任链设计模式将处理者链式串联，将请求沿着处理者链传递，处理者链上的处理者对请求进行处理，处理结束后可以选择终止请求传递或者继续请求传递。

适用于**请求具有可传递性、多节点可处理、且处理者可能动态变化**的业务场景。

![[attachments/Pasted image 20250902094939.png]]
## 参数请求校验
以创建优惠券模板请求为例，请求参数校验时，需要检验请求信息、校验数据库信息、校验数据逻辑，这些校验逻辑彼此独立，单一线性，可以适用责任链模式。将这些校验抽象为独立的处理器，并组合串联为处理者链。

![[attachments/Pasted image 20250902101551.png]]

处理器上下文存储了处理器链标志于处理器链的映射，以标志区分不同的过滤器链。需要注意的是通过实现 ApplicationContextAware 和 CommondLineRunner 接口从而从 Spring Application 容器中获取 Bean 对象，并利用 Bean 生命周期完成容器初始化。 

初始化过滤器链时，根据过滤器链标志创建过滤器链，按照优先级排序处理器后，将处理链标志和处理者链映射存储到 map 中。

```Java
@Component  
public final class MerchantAdminChainContext<T> implements ApplicationContextAware, CommandLineRunner {  
  
    /**  
     * 应用上下文，我们这里通过 Spring IOC 获取 Bean 实例  
     */  
    private ApplicationContext applicationContext;  
    /**  
     * 保存商家后管责任链实现类  
     */  
    private final Map<String, List<MerchantAdminAbstractChainHandler>> abstractChainHandlerContainer = new HashMap<>();  
  
    /**  
     * 责任链组件执行  
     *  
     * @param mark         责任链组件标识  
     * @param requestParam 请求参数  
     */  
    public void handler(String mark, T requestParam) {  
        // 根据 mark 标识从责任链容器中获取一组责任链实现 Bean 集合  
        List<MerchantAdminAbstractChainHandler> abstractChainHandlers = abstractChainHandlerContainer.get(mark);  
        if (CollectionUtils.isEmpty(abstractChainHandlers)) {  
            throw new RuntimeException(String.format("[%s] Chain of Responsibility ID is undefined.", mark));  
        }  
        abstractChainHandlers.forEach(each -> each.handler(requestParam));  
    }  
  
    @Override  
    public void run(String... args) throws Exception {  
        // 从 Spring IOC 容器中获取指定接口 Spring Bean 集合  
        Map<String, MerchantAdminAbstractChainHandler> chainFilterMap = applicationContext.getBeansOfType(MerchantAdminAbstractChainHandler.class);  
        chainFilterMap.forEach((beanName, bean) -> {  
            // 判断 Mark 是否已经存在抽象责任链容器中，如果已经存在直接向集合新增；如果不存在，创建 Mark 和对应的集合  
            List<MerchantAdminAbstractChainHandler> abstractChainHandlers = abstractChainHandlerContainer.getOrDefault(bean.mark(), new ArrayList<>());  
            abstractChainHandlers.add(bean);  
            abstractChainHandlerContainer.put(bean.mark(), abstractChainHandlers);  
        });  
        abstractChainHandlerContainer.forEach((mark, unsortedChainHandlers) -> {  
            // 对每个 Mark 对应的责任链实现类集合进行排序，优先级小的在前  
            unsortedChainHandlers.sort(Comparator.comparing(Ordered::getOrder));  
        });  
    }  
  
    @Override  
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
        this.applicationContext = applicationContext;  
    }  
}
```

处理器接口中定义了处理方法和处理器标识，处理方法需要实现类实现，处理器标志用于区分处理器链。

需要重点关注该接口继承了 Ordered 接口，用以在构造过滤器链时将处理器按优先级进行排序。

```Java
/**  
 * 抽象商家后管业务责任链组件  
 */  
public interface MerchantAdminAbstractChainHandler<T> extends Ordered {  
  
    /**  
     * 执行责任链逻辑  
     *  
     * @param requestParam 责任链执行入参  
     */  
    void handler(T requestParam);  
  
    /**  
     * @return 责任链组件标识  
     */  
    String mark();  
}
```

以一个具体的处理器接口实现类为例，在该处理器中处理方法校验创建优惠券模板的请求参数是否满足业务要求，并指定返回的处理器链标志，最后指定了优先级。

```Java
@Component  
public class CouponTemplateCreateParamBaseVerifyChainFilter implements MerchantAdminAbstractChainHandler<CouponTemplateSaveReqDTO> {  
  
    private final int maxStock = 20000000;  
  
    @Override  
    public void handler(CouponTemplateSaveReqDTO requestParam) {  
        boolean targetAnyMatch = Arrays.stream(DiscountTargetEnum.values())  
                .anyMatch(enumConstant -> enumConstant.getType() == requestParam.getTarget());  
        if (!targetAnyMatch) {  
            // 此处已经基本能判断数据请求属于恶意攻击，可以上报风控中心进行封禁账号  
            throw new ClientException("优惠对象值不存在");  
        }  
        if (ObjectUtil.equal(requestParam.getTarget(), DiscountTargetEnum.ALL_STORE_GENERAL)  
                && StrUtil.isNotEmpty(requestParam.getGoods())) {  
            throw new ClientException("优惠券全店通用不可设置指定商品");  
        }  
        if (ObjectUtil.equal(requestParam.getTarget(), DiscountTargetEnum.PRODUCT_SPECIFIC)  
                && StrUtil.isEmpty(requestParam.getGoods())) {  
            throw new ClientException("优惠券商品专属未设置指定商品");  
        }  
  
        boolean typeAnyMatch = Arrays.stream(DiscountTypeEnum.values())  
                .anyMatch(enumConstant -> enumConstant.getType() == requestParam.getType());  
        if (!typeAnyMatch) {  
            // 此处已经基本能判断数据请求属于恶意攻击，可以上报风控中心进行封禁账号  
            throw new ClientException("优惠类型不存在");  
        }  
  
        Date now = new Date();  
        if (requestParam.getValidStartTime().before(now)) {  
            // 为了方便大家测试，不用关注这个时间，这里取消异常抛出  
            // throw new ClientException("有效期开始时间不能早于当前时间");  
        }  
  
        if (requestParam.getStock() <= 0 || requestParam.getStock() > maxStock) {  
            // 此处已经基本能判断数据请求属于恶意攻击，可以上报风控中心进行封禁账号  
            throw new ClientException("库存数量设置异常");  
        }  
  
        if (!JSON.isValid(requestParam.getReceiveRule())) {  
            // 此处已经基本能判断数据请求属于恶意攻击，可以上报风控中心进行封禁账号  
            throw new ClientException("领取规则格式错误");  
        }  
        if (!JSON.isValid(requestParam.getConsumeRule())) {  
            // 此处已经基本能判断数据请求属于恶意攻击，可以上报风控中心进行封禁账号  
            throw new ClientException("消耗规则格式错误");  
        }  
    }  
  
    @Override  
    public String mark() {  
        return MERCHANT_ADMIN_CREATE_COUPON_TEMPLATE_KEY.name();  
    }  
  
    @Override  
    public int getOrder() {  
        return 10;  
    }  
}
```
