为了提高销售额，平台都会给用户发放优惠券，这些优惠券不需要用户执行抢券动作，有平台自动发给指定的目标用户群体。现给出存有目标用户信息的百万级别 Excel，需要根据用户信息 Excel 执行优惠券分发动作，确保高效率的执行分发动作。

为什么是基于用户 Excel 执行分发动作？一般来说目标用户需要由用户画像系统生成，画像系统可以给目标用户打上标签，也可以直接生成目标用户的 excel 文件。平台可以根据标签执行分发动作，但是由于没有用户画像系统，采用第二种方式，模拟目标用户 excel，读取该 excel 并执行优惠券推送任务。

现在就有两个问题，如何处理大规模 Excel？如何自动高效的将优惠券分发推送给用户？

# 推送任务生成阶段
由于没有用户画像系统，所以适用 Faker 自动生成一百万的用户信息 Excel，文件大小大概在 30M。

得到用户 Excel 文件后，首先应该分析目标用户群体数量即 Excel 行数，以便后续统计发放成功数量和发放失败数量。那么如何处理 Excel 文件？Hutool 提供了处理 Excel 的工具类。但是处理时间极长，通过 jvisualvm 监控内存发现，30M 的 Excel 文件处理，内存占用达到惊人的 3GB！决定放弃使用 Hutool 自带的工具类处理 Excel。

## EasyExcle 处理大规模 Excle
引入 EasyExcel 处理同样的百万用户信息 Excel，同样使用 jvisualvm 查看内存后发现内存占用仅仅只有 300 M上下，且速度大幅领先 Hutool 工具类。

```Java
// 读取 excel 文件通过监听器获取总行数
RowCountListener listener = new RowCountListener();  
EasyExcel.read(delayJsonObject.getString("fileAddress"), listener).sheet().doRead();  
int totalRows = listener.getRowCount();
```

## 结合丢弃策略线程池异步处理 excel
创建优惠券推送任务时，除了需要优惠券相关信息、推送方式、任务类型等外，还需要获取用户规模，即 excel 行数，方便后续统计推送成功人数和推送失败人数。尽管使用 easyExcel 已经极大的优化了 excel 处理速度，但是统计百万级 excel 行数平均耗时仍然在 5s 左右，对于一个服务接口来说绝对不能接受。所以使用线程池异步的统计 excle 行数并执行更新动作。

```Java
/**  
 * 线程池采用“CPU核数 ~ 2×核数”配置 + 无队列（SynchronousQueue）+ 丢弃策略（DiscardPolicy），  
 * 确保接口响应速度不被异步任务拖慢，并在高负载时自动放弃非关键任务，避免阻塞和雪崩效应。  
 */
private final ExecutorService executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), Runtime.getRuntime().availableProcessors() << 1, 60, TimeUnit.SECONDS, new SynchronousQueue<>(), new ThreadPoolExecutor.DiscardPolicy());

// 为什么需要统计行数？因为发送后需要比对所有优惠券是否都已发放到用户账号  
// 100 万数据大概需要 4 秒才能返回前端，如果加上验证将会时间更长，所以这里将最耗时的统计操作异步化  
JSONObject delayJsonObject = JSONObject.of("fileAddress", requestParam.getFileAddress(), "couponTaskId", couponTaskDO.getId());  
executorService.execute(() -> refreshCouponTaskSendNum(delayJsonObject));
```
## 线程池丢弃任务兜底策略
既然任务可能被丢弃，所以为了尽最大可能保障解析 excel 任务被执行，设计了兜底策略。利用 Redission 延时队列封装了阻塞队列，将推送任务发送一份到延时阻塞队列中，并在容器启动时开启一个独立线程循环处理该任务，执行解析动作，并利用任务状态进行幂等控制。

1. 将推送任务发送到延时阻塞队列

```Java
// 假设刚把消息提交到线程池，但是任务被丢弃，我们通过延迟队列进行兜底 RefreshRBlockingDeque<Object> blockingDeque = redissonClient.getBlockingDeque("COUPON_TASK_SEND_NUM_DELAY_QUEUE");  
RDelayedQueue<Object> delayedQueue = redissonClient.getDelayedQueue(blockingDeque);  
// 这里延迟时间设置 20 秒，原因是我们笃定上面线程池 20 秒之内就能结束任务  
delayedQueue.offer(delayJsonObject, 20, TimeUnit.SECONDS);
```

2. 容器启动时利用 Bean 生命周期，开启单线程循环处理延时阻塞队列内容

```Java
@Service  
@RequiredArgsConstructor  
class RefreshCouponTaskDelayQueueRunner implements CommandLineRunner {  
  
    private final CouponTaskMapper couponTaskMapper;  
    private final RedissonClient redissonClient;  
  
    @Override  
    public void run(String... args) throws Exception {  
        Executors.newSingleThreadExecutor(runnable -> {  
            Thread thread = new Thread(runnable);  
            thread.setName("delay_coupon-task_send-num_consumer");  
            thread.setDaemon(Boolean.TRUE);  
            return thread;  
        }).execute(() -> {  
            RBlockingDeque<JSONObject> blockingDeque = redissonClient.getBlockingDeque("COUPON_TASK_SEND_NUM_DELAY_QUEUE");  
            for (; ; ) {  
                try {  
                    // 获取延迟队列已到达时间元素  
                    JSONObject delayJsonObject = blockingDeque.take();  
                    if (delayJsonObject != null) {  
                        // 获取优惠券推送记录，查看发送条数是否已经有值，有的话代表上面线程池已经处理完成，无需再处理  
                        CouponTaskDO couponTaskDO = couponTaskMapper.selectById(delayJsonObject.getLong("couponTaskId"));  
                        if (couponTaskDO.getSendNum() == null) {  
                            refreshCouponTaskSendNum(delayJsonObject);  
                        }  
                    }  
                } catch (Throwable ignored) {  
                }  
            }  
        });  
    }  
}
```

## 生成推送任务阶段总览
推送任务除了涉及到优惠券信息、推送方式、任务类型等内容外，还需要记录用户总量，即 excel 总行数。但是计算 excel 总行数是个耗时任务，不应该在接口中同步计算，否则很有可能拖垮系统。因此引入丢弃策略线程池异步处理任务，为了处理丢弃任务还利用 Redission 延时阻塞队列设计了兜底策略，兜底处理丢弃的推送任务，保障数据一致性。

```Java
/**  
 * @author Lenovo * @description 针对表【t_coupon_task(优惠券模板发送任务表)】的数据库操作Service实现  
 * @createDate 2025-07-28 09:40:59  
 */@Service  
@RequiredArgsConstructor  
public class CouponTaskServiceImpl extends ServiceImpl<CouponTaskMapper, CouponTaskDO> implements CouponTaskService {  
  
    private final CouponTemplateService couponTemplateService;  
    private final CouponTaskMapper couponTaskMapper;  
    private final RedissonClient redissonClient;  
    private final CouponTaskActualExecuteProducer couponTaskActualExecuteProducer;  
  
    /**  
     * 线程池采用“CPU核数 ~ 2×核数”配置 + 无队列（SynchronousQueue）+ 丢弃策略（DiscardPolicy），  
     * 确保接口响应速度不被异步任务拖慢，并在高负载时自动放弃非关键任务，避免阻塞和雪崩效应。  
     */  
    private final ExecutorService executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), Runtime.getRuntime().availableProcessors() << 1, 60, TimeUnit.SECONDS, new SynchronousQueue<>(), new ThreadPoolExecutor.DiscardPolicy());  
  
    @Transactional(rollbackFor = Exception.class)  
    @Override  
    public void createCouponTask(CouponTaskCreateReqDTO requestParam) {  
        // 验证非空参数  
        // 验证参数是否正确，比如文件地址是否为我们期望的格式、是否已经登录等。  
        // 验证参数依赖关系，比如选择定时发送，发送时间是否不为空等  
        CouponTemplateQueryRespDTO couponTemplate = couponTemplateService.findCouponTemplateById(requestParam.getCouponTemplateId());  
        if (couponTemplate == null) {  
            throw new ClientException("优惠券模板不存在，请检查提交信息是否正确");  
        }  
        // ......  
  
        // 构建优惠券推送任务数据库持久层实体  
        CouponTaskDO couponTaskDO = BeanUtil.copyProperties(requestParam, CouponTaskDO.class);  
        couponTaskDO.setBatchId(IdUtil.getSnowflakeNextId());  
        couponTaskDO.setOperatorId(Long.parseLong(UserContext.getUserId()));  
        couponTaskDO.setShopNumber(UserContext.getShopNumber());  
        couponTaskDO.setStatus(Objects.equals(requestParam.getSendType(), CouponTaskSendTypeEnum.IMMEDIATE.getType()) ? CouponTaskStatusEnum.IN_PROGRESS.getStatus() : CouponTaskStatusEnum.PENDING.getStatus());  
  
        // 保存优惠券推送任务记录到数据库  
        couponTaskMapper.insert(couponTaskDO);  
  
        // 为什么需要统计行数？因为发送后需要比对所有优惠券是否都已发放到用户账号  
        // 100 万数据大概需要 4 秒才能返回前端，如果加上验证将会时间更长，所以这里将最耗时的统计操作异步化  
        JSONObject delayJsonObject = JSONObject.of("fileAddress", requestParam.getFileAddress(), "couponTaskId", couponTaskDO.getId());  
        executorService.execute(() -> refreshCouponTaskSendNum(delayJsonObject));  
  
        // 假设刚把消息提交到线程池，但是任务被丢弃，我们通过延迟队列进行兜底 Refresh        RBlockingDeque<Object> blockingDeque = redissonClient.getBlockingDeque("COUPON_TASK_SEND_NUM_DELAY_QUEUE");  
        RDelayedQueue<Object> delayedQueue = redissonClient.getDelayedQueue(blockingDeque);  
        // 这里延迟时间设置 20 秒，原因是我们笃定上面线程池 20 秒之内就能结束任务  
        delayedQueue.offer(delayJsonObject, 20, TimeUnit.SECONDS);  
  
        // 如果是立即发送任务，直接调用消息队列进行发送流程  
        if (Objects.equals(requestParam.getSendType(), CouponTaskSendTypeEnum.IMMEDIATE.getType())) {  
            // 执行优惠券推送业务，正式向用户发放优惠券  
            CouponTaskExecuteEvent couponTaskExecuteEvent = CouponTaskExecuteEvent.builder()  
                    .couponTaskId(couponTaskDO.getId())  
                    .build();  
            couponTaskActualExecuteProducer.sendMessage(couponTaskExecuteEvent);  
        }  
    }  
  
    private void refreshCouponTaskSendNum(JSONObject delayJsonObject) {  
        // 通过 EasyExcel 监听器获取 Excel 中所有行数  
        RowCountListener listener = new RowCountListener();  
        EasyExcel.read(delayJsonObject.getString("fileAddress"), listener).sheet().doRead();  
        int totalRows = listener.getRowCount();  
  
        // 刷新优惠券推送记录中发送行数  
        CouponTaskDO updateCouponTaskDO = CouponTaskDO.builder().id(delayJsonObject.getLong("couponTaskId")).sendNum(totalRows).build();  
        couponTaskMapper.updateById(updateCouponTaskDO);  
        System.out.println(Thread.currentThread().getName() + "execute refreshCouponTaskSendNum()");  
    }  
  
    /**  
     * 优惠券延迟刷新发送条数兜底消费者｜这是兜底策略，一般来说不会执行这段逻辑  
     * 如果延迟消息没有持久化成功，或者 Redis 挂了怎么办？后续可以人工处理  
     * <p>  
     * 作者：马丁  
     * 加项目群：早加入就是优势！500人内部项目群，分享的知识总有你需要的 <a href="https://t.zsxq.com/cw7b9" />  
     * 开发时间：2024-07-12  
     */    @Service  
    @RequiredArgsConstructor    class RefreshCouponTaskDelayQueueRunner implements CommandLineRunner {  
  
        private final CouponTaskMapper couponTaskMapper;  
        private final RedissonClient redissonClient;  
  
        @Override  
        public void run(String... args) throws Exception {  
            Executors.newSingleThreadExecutor(runnable -> {  
                Thread thread = new Thread(runnable);  
                thread.setName("delay_coupon-task_send-num_consumer");  
                thread.setDaemon(Boolean.TRUE);  
                return thread;  
            }).execute(() -> {  
                RBlockingDeque<JSONObject> blockingDeque = redissonClient.getBlockingDeque("COUPON_TASK_SEND_NUM_DELAY_QUEUE");  
                for (; ; ) {  
                    try {  
                        // 获取延迟队列已到达时间元素  
                        JSONObject delayJsonObject = blockingDeque.take();  
                        if (delayJsonObject != null) {  
                            // 获取优惠券推送记录，查看发送条数是否已经有值，有的话代表上面线程池已经处理完成，无需再处理  
                            CouponTaskDO couponTaskDO = couponTaskMapper.selectById(delayJsonObject.getLong("couponTaskId"));  
                            if (couponTaskDO.getSendNum() == null) {  
                                refreshCouponTaskSendNum(delayJsonObject);  
                            }  
                        }  
                    } catch (Throwable ignored) {  
                    }  
                }  
            });  
        }  
    }  
}
```

# 分发任务执行阶段
推送任务阶段根据 excel 用户信息，将指定的优惠券推分发给用户的过程，该过程扣减优惠券模板库存，然后将优惠券写入用户优惠券表。

## 逐条分发过程
逐条分发逻辑实现非常简单，使用 EasyExcel 逐行处理用户信息时，直接逐行的执行 Redis 扣减操作，用户优惠券表新增行操作，但是存在严重性能问题。

### Redis 缓存键设计
优惠券模板信息使用 Hash 结构存储在 Redis 中，用户领券记录使用 Zset 保存，其中 value 记录优惠券Id 和 用户优惠券Id，score 记录用户领券时间，利用 score 可以便捷实现按领取时间排序。

后续由于涉及优惠券秒杀场景，优惠券秒杀场景中，一定是先执行缓存操作然后再执行数据库扣减操作。因此在分发场景也必须保持相同的操作逻辑，避免出现超发问题。假设秒杀 A 场景先操作 Redis 然后操作数据库，而分发 B 场景先操作数据然后操作 Redis，若 B 操作数据库成功但是操作 Redis 失败，而 A 操作 Redis 成功，操作数据库成功，必然导致超发问题。

```Java
// 正式开始执行优惠券推送任务  
var readExcelDistributionListener = new ReadExcelDistributionListener(  
        couponTaskId,  
        couponTemplateDO,  
        stringRedisTemplate,  
        couponTemplateMapper,  
        userCouponMapper,  
        couponTaskMapper  
);  
        EasyExcel.read(couponTaskDO.getFileAddress(), CouponTaskExcelObject.class, readExcelDistributionListener).sheet().doRead();
```

逐行操作 Redis 和 数据库。
```Java
@RequiredArgsConstructor  
public class ReadExcelDistributionListener extends AnalysisEventListener<CouponTaskExcelObject> {  
  
    private final Long couponTaskId;  
    private final CouponTemplateDO couponTemplateDO;  
    private final StringRedisTemplate stringRedisTemplate;  
    private final CouponTemplateMapper couponTemplateMapper;  
    private final UserCouponMapper userCouponMapper;  
    private final CouponTaskMapper couponTaskMapper;  
  
    @Override  
    public void invoke(CouponTaskExcelObject data, AnalysisContext context) {  
        // 通过缓存判断优惠券模板记录库存是否充足  
        String couponTemplateKey = String.format(EngineRedisConstant.COUPON_TEMPLATE_KEY, couponTemplateDO.getId());  
        Long stock = stringRedisTemplate.opsForHash().increment(couponTemplateKey, "stock", -1);  
        if (stock < 0) {  
            // 优惠券模板缓存库存不足扣减失败  
            return;  
        }  
  
        // 扣减优惠券模板库存，如果扣减成功，这里会返回 1，代表修改记录成功；否则返回 0，代表没有修改成功  
        int decrementResult = couponTemplateMapper.decrementCouponTemplateStock(couponTemplateDO.getShopNumber(), couponTemplateDO.getId(), 1);  
        if (!SqlHelper.retBool(decrementResult)) {  
            // 优惠券模板数据库库存不足扣减失败  
            return;  
        }  
  
        // 添加用户领券记录到数据库  
        Date now = new Date();  
        DateTime validEndTime = DateUtil.offsetHour(now, JSON.parseObject(couponTemplateDO.getConsumeRule()).getInteger("validityPeriod"));  
        UserCouponDO userCouponDO = UserCouponDO.builder()  
                .couponTemplateId(couponTemplateDO.getId())  
                .userId(Long.parseLong(data.getUserId()))  
                .receiveTime(now)  
                .receiveCount(1) // 代表第一次领取该优惠券  
                .validStartTime(now)  
                .validEndTime(validEndTime)  
                .source(CouponSourceEnum.PLATFORM.getType())  
                .status(CouponStatusEnum.EFFECTIVE.getType())  
                .createTime(new Date())  
                .updateTime(new Date())  
                .delFlag(0)  
                .build();  
        try {  
            userCouponMapper.insert(userCouponDO);  
        } catch (BatchExecutorException bee) {  
            // 用户已领取优惠券，会被唯一索引校验住，直接返回即可  
            return;  
        }  
  
        // 添加优惠券到用户已领取的 Redis 优惠券列表中  
        String userCouponListCacheKey = String.format(EngineRedisConstant.USER_COUPON_TEMPLATE_LIST_KEY, data.getUserId());  
        String userCouponItemCacheKey = StrUtil.builder()  
                .append(couponTemplateDO.getId())  
                .append("_")  
                .append(userCouponDO.getId())  
                .toString();  
        stringRedisTemplate.opsForZSet().add(userCouponListCacheKey, userCouponItemCacheKey, now.getTime());  
    }  
  
    @Override  
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {  
        // 确保所有用户都已经接到优惠券后，设置优惠券推送任务完成时间  
        CouponTaskDO couponTaskDO = CouponTaskDO.builder()  
                .id(couponTaskId)  
                .status(CouponTaskStatusEnum.SUCCESS.getStatus())  
                .completionTime(new Date())  
                .build();  
        couponTaskMapper.updateById(couponTaskDO);  
    }  
}
```

经过测试 excel 规模为 5000 时，逐行处理耗时在 1 min 上下，这绝对无法接受。经过分析很容易发现逐行处理的短板所在。对于规模为 N 的 excel，需要经过至少 2N 次网络通信，也就是说处理过程中把大量时间浪费在了网络通信过程。并且整个消费者处理时间极长。解决思路也很简单，利用批处理实现上述逻辑。

## 批处理优惠券分发
现在需要处理消费者处理时间过长和逐行处理网络耗时巨大两个问题。分发优惠券可以分为：
1. 扣减 Redis 优惠券模板库存数量
2. 扣减数据库领券数量，新增用户领券表记录
3. 将优惠券添加到 Redis 领券记录中
逐行处理过程中，在一次消费过程中同步进行这三步，且每次都需要向数据库新增数据，然后将优惠券添加到用户 Redis 领券记录。一来同步执行消费者消费时间被拉长，二来大量时间浪费在了第 2 3 步网络通信过程中。因此为了解决消费时间过长问题，将第一步和第二三步拆分，同时引入批处理操作，避免多次网络通信。

### 消费逻辑拆分
在一个消费逻辑中执行扣减 Redis 优惠券模板库存、扣减数据库优惠券模板库存新增用户领券记录和新增 Redis 用户领券记录拖长了整个消费时间。因为 Redis 的操作较快，为了避免拖长 EasyExcel 处理 excel 时间，故分离第一步扣减 Redis 优惠券库操作。

引入缓冲池分离扣减 Redis 优惠券库操作，EasyExcel 逐行处理 Excel 时通过 lua 脚本先执行扣减动作，然后将分发成功的用户记录添加到用户缓冲池，同时 lua 脚本还保障了原子性。

通过缓冲池，消费者能够高效的利用 EasyExcel 将带读取数据添加到用户缓冲池，而利用缓冲池用户信息，就可以执行数据库扣减动作和新增用户领券记录动作，并最后将领券记录添加到用户 Redis 领券记录中。

现在来看具体思路。利用缓冲池分离步骤 1（读取 Excel 扣减 Redis 优惠券模板）和步骤2（操作数据库扣减优惠券模板库存）步骤 3（新增用户领券记录）。现在使用两个消费者A B说明具体流程。消费者 A 使用 EasyExcel 逐行读取 excel，扣减优惠券模板并新增用户到用户缓冲池，当处理数量达到 5000 构成一批次后（当读取文文件结束时也会发送消息）、发送消息给消费者 B。消费者 B 收到批处理消息，开始读取缓冲池，执行数据库批处理操作和 Redis 批处理操作。

由于需要记录读取数量，还应该记录 Excel 读取进度。将 Excel 读取进度存储到 Redis 中，当发生意外需要重新读取文件时，可以直接跳过小于当前进度的行。同时还可以用户定位分发失败的记录。

```Java
/**  
 * 消费者 A 操作优惠券模板和缓冲池
 * 处理优惠券推送消息。将优惠券推送到用户领券列表。  
 */  
@Component  
@RequiredArgsConstructor  
@RocketMQMessageListener(  
        topic = "one-coupon_distribution-service_coupon-task-execute_topic${unique-name:}",  
        consumerGroup = "one-coupon_distribution-service_coupon-task-execute_cg${unique-name:}"  
)  
@Slf4j(topic = "CouponTaskExecuteConsumer")  
public class CouponTaskExecuteConsumer implements RocketMQListener<MessageWrapper<CouponTaskExecuteEvent>> {  
  
    private final CouponTaskMapper couponTaskMapper;  
    private final CouponTemplateMapper couponTemplateMapper;  
    private final StringRedisTemplate stringRedisTemplate;  
    private final CouponTaskFailMapper couponTaskFailMapper;  
    private final CouponExecuteDistributionProducer couponExecuteDistributionProducer;  
  
    /**  
     * 操作 Redis 分发用户缓冲区，执行优惠券分发任务。  
     * 读取用户 excel 信息，操作 Redis，扣减库存，将领券用户新增到领券用户集合。  
     */  
    @NoMQDuplicateConsume(  
            keyPrefix = "coupon_task_execute:idempotent:",  
            key = "#messageWrapper.message.couponTaskId",  
            keyTimeout = 120  
    )  
    @Override  
    public void onMessage(MessageWrapper<CouponTaskExecuteEvent> messageWrapper) {  
        // 开头打印日志，平常可 Debug 看任务参数，线上可报平安（比如消息是否消费，重新投递时获取参数等）  
        log.info("[消费者] 执行优惠券推送任务，开始操作用户缓冲池，消息体：{}", JSON.toJSONString(messageWrapper));  
  
        // 1. 校验推送任务状态与优惠券模板状态  
        var couponTaskId = messageWrapper.getMessage().getCouponTaskId();  
        var couponTaskDO = couponTaskMapper.selectById(couponTaskId);  
        if (ObjectUtil.notEqual(couponTaskDO.getStatus(), CouponTaskStatusEnum.IN_PROGRESS.getStatus())) {  
            log.error("[消费者] 优惠券推送任务异常结束，未开始操作分发用户缓冲池 - 推送任务状态异常：{}，已终止推送", couponTaskDO.getStatus());  
            return;  
        }  
  
        var queryWrapper = Wrappers.lambdaQuery(CouponTemplateDO.class)  
                .eq(CouponTemplateDO::getId, couponTaskDO.getCouponTemplateId())  
                .eq(CouponTemplateDO::getShopNumber, couponTaskDO.getShopNumber());  
        var couponTemplateDO = couponTemplateMapper.selectOne(queryWrapper);  
        var status = couponTemplateDO.getStatus();  
        if (ObjectUtil.notEqual(status, CouponTemplateStatusEnum.ACTIVE.getStatus())) {  
            log.error("[消费者] 优惠券推送异常结束，未开始操作分发用户缓冲池 - 优惠券ID：{}，优惠券模板异常状态：{}", couponTaskDO.getCouponTemplateId(), status);  
            return;  
        }  
  
        // 2. 扫描用户信息 excel ，使用监听器在 Redis 执行分发操作。  
        var readExcelDistributionListener = new ReadExcelDistributionListener(  
                couponTaskDO,  
                couponTemplateDO,  
                couponTaskFailMapper,  
                stringRedisTemplate,  
                couponExecuteDistributionProducer  
        );  
        EasyExcel.read(couponTaskDO.getFileAddress(), CouponTaskExcelObject.class, readExcelDistributionListener).sheet().doRead();  
    }  
}

@RequiredArgsConstructor  
@Slf4j  
public class ReadExcelDistributionListener extends AnalysisEventListener<CouponTaskExcelObject> {  
  
    private final CouponTaskDO couponTaskDO;  
    private final CouponTemplateDO couponTemplateDO;  
    private final CouponTaskFailMapper couponTaskFailMapper;  
  
    private final StringRedisTemplate stringRedisTemplate;  
    private final CouponExecuteDistributionProducer couponExecuteDistributionProducer;  
  
    // 记录当前处理到行  
    private int rowCount = 1;  
    private final static String STOCK_DECREMENT_AND_BATCH_SAVE_USER_RECORD_LUA_PATH = "lua/stock_decrement_and_batch_save_user_record.lua";  
    private final static int BATCH_USER_COUPON_SIZE = 5000;  
  
    @Override  
    public void invoke(CouponTaskExcelObject data, AnalysisContext context) {  
        Long couponTaskId = couponTaskDO.getId();  
        // 1. 从 Redis 中获取读取进度并跳过。  
        String templateTaskExecuteProgressKey = String.format(DistributionRedisConstant.TEMPLATE_TASK_EXECUTE_PROGRESS_KEY, couponTaskId);  
        String progress = stringRedisTemplate.opsForValue().get(templateTaskExecuteProgressKey);  
        if (StrUtil.isNotBlank(progress) && Integer.parseInt(progress) >= rowCount) {  
            ++rowCount;  
            return;  
        }  
  
        // 2. 发送 lua 脚本，执行优惠券扣减操作和向缓冲池增加用户操作。  
        DefaultRedisScript<Long> buildLuaScript = Singleton.get(STOCK_DECREMENT_AND_BATCH_SAVE_USER_RECORD_LUA_PATH, () -> {  
            DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();  
            redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(STOCK_DECREMENT_AND_BATCH_SAVE_USER_RECORD_LUA_PATH)));  
            redisScript.setResultType(Long.class);  
            return redisScript;  
        });  
  
        // 2.0 构造优惠券模板库存 key 和领券用户缓冲池 key，传入 lua 脚本并执行。  
        // coupon_engine:template:${couponId}  
        String couponTemplateKey = String.format(EngineRedisConstant.COUPON_TEMPLATE_KEY, couponTemplateDO.getId());  
        // coupon_engine:template:${couponTaskId}  
        String batchUserSetKey = String.format(DistributionRedisConstant.TEMPLATE_TASK_EXECUTE_BATCH_USER_KEY, couponTaskId);  
        Map<Object, Object> userRowNumMap = MapUtil.builder()  
                .put("userId", data.getUserId())  
                .put("rowNum", rowCount)  
                .build();  
        Long combinedFiled = stringRedisTemplate.execute(buildLuaScript, ListUtil.of(couponTemplateKey, batchUserSetKey), JSON.toJSONString(userRowNumMap));  
  
        // 2.1 优惠券不存在或者优惠券数量不足，扣减优惠券库存失败，向 Redis 同步记录，并持久化分发失败记录，跳到下一行处理。  
        boolean deductSuccess = combinedFiled != null && StockDecrementReturnCombinedUtil.extractFirstField(combinedFiled);  
        if (!deductSuccess) {  
            // 同步当前执行进度到缓存  
            stringRedisTemplate.opsForValue().set(templateTaskExecuteProgressKey, String.valueOf(rowCount));  
            ++rowCount;  
  
            // 添加到 t_coupon_task_fail 并标记错误原因，方便后续查看未成功发送的原因和记录  
            Map<Object, Object> objectMap = MapUtil.builder()  
                    .put("rowNum", rowCount)  
                    .put("cause", "优惠券模板无库存")  
                    .build();  
            CouponTaskFailDO couponTaskFailDO = CouponTaskFailDO.builder()  
                    .batchId(couponTaskDO.getBatchId())  
                    .jsonObject(JSON.toJSONString(objectMap, SerializerFeature.WriteMapNullValue))  
                    .build();  
            couponTaskFailMapper.insert(couponTaskFailDO);  
            return;  
        }  
  
        int batchUserSetCacheSize = StockDecrementReturnCombinedUtil.extractSecondField(combinedFiled.intValue());  
  
        // 2.2 优惠券扣减成功，但缓冲池数量未达到 5000 阈值，同步记录并跳过当前行。  
        if (batchUserSetCacheSize < BATCH_USER_COUPON_SIZE) {  
            // 同步当前 Excel 执行进度到缓存  
            stringRedisTemplate.opsForValue().set(templateTaskExecuteProgressKey, String.valueOf(rowCount));  
            ++rowCount;  
            return;  
        }  
  
        // 2.3 缓冲池数量达到阈值，触发批量操作，向用户分发优惠券，同步进度。  
        // 缓冲池数量 > 5000 后，频繁触发消息发送，单消费者利用 % 解决该问题。多消费者需要结合 Redis 阶段标记和原子变量行数，限制并发条件下的消费者消息发送能力。  
        if (batchUserSetCacheSize % BATCH_USER_COUPON_SIZE == 0) {  
            CouponTemplateDistributionEvent couponTemplateDistributionEvent = CouponTemplateDistributionEvent.builder()  
                    .couponTaskId(couponTaskId)  
                    .shopNumber(couponTaskDO.getShopNumber())  
                    .couponTemplateId(couponTemplateDO.getId())  
                    .couponTaskBatchId(couponTaskDO.getBatchId())  
                    .couponTemplateConsumeRule(couponTemplateDO.getConsumeRule())  
                    .batchUserSetSize(batchUserSetCacheSize)  
                    .distributionEndFlag(Boolean.FALSE)  
                    .validEndTime(couponTemplateDO.getValidEndTime())  
                    .build();  
            log.info("[消费者] 执行优惠券推送任务, 缓冲池 {} 达到阈值，发送阈值处理消息 {}", batchUserSetKey, couponTemplateDistributionEvent);  
            couponExecuteDistributionProducer.sendMessage(couponTemplateDistributionEvent);  
        }  
        // 同步当前执行进度到缓存  
        stringRedisTemplate.opsForValue().set(templateTaskExecuteProgressKey, String.valueOf(rowCount));  
        ++rowCount;  
    }  
  
    @Override  
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {  
        // 用户信息 excel 解析完成，可能未达到批操作阈值，但仍然需要执行分发动作。  
        String batchUserSetKey = String.format(DistributionRedisConstant.TEMPLATE_TASK_EXECUTE_BATCH_USER_KEY, couponTaskDO.getId());  
        CouponTemplateDistributionEvent couponTemplateExecuteEvent = CouponTemplateDistributionEvent.builder()  
                .distributionEndFlag(Boolean.TRUE) // 设置解析完成标识  
                .shopNumber(couponTaskDO.getShopNumber())  
                .couponTemplateId(couponTemplateDO.getId())  
                .couponTemplateConsumeRule(couponTemplateDO.getConsumeRule())  
                .couponTaskBatchId(couponTaskDO.getBatchId())  
                .couponTaskId(couponTaskDO.getId())  
                .validEndTime(couponTemplateDO.getValidEndTime())  
                .build();  
        log.info("[消费者] 执行优惠券推送任务, 用户列表读取完毕，发送 excel 读取结束消息 {}，分发用户缓冲池 {}", couponTemplateExecuteEvent, batchUserSetKey);  
        couponExecuteDistributionProducer.sendMessage(couponTemplateExecuteEvent);  
    }  
}
```

```Lua
-- 封装扣减库存和增减用户领取记录两个操作。扣减成功后，将用户记录增加到领券用户缓存池。  
-- 并且使用位操作封装 扣减结果 和 已经领券用户数量 两个返回值。  
  
-- 定义最大值和位数  
local SECOND_FIELD_BITS = 13  
  
-- 将两个字段组合成一个int  
local function combineFields(firstField, secondField)  
    local firstFieldValue = firstField and 1 or 0  
    return (firstFieldValue * 2 ^ SECOND_FIELD_BITS) + secondField  
end  
  
-- Lua脚本开始  
local key = KEYS[1] -- Redis Key  
local userSetKey = KEYS[2] -- 用户领券 Set 的 Keylocal userIdAndRowNum = ARGV[1] -- 用户 ID 和 Excel 所在行数  
  
-- 获取库存  
local stock = tonumber(redis.call('HGET', key, 'stock'))  
  
-- 检查库存是否大于0  
if stock == nil or stock <= 0 then  
    return combineFields(false, redis.call('SCARD', userSetKey))  
end  
  
-- 自减库存  
redis.call('HINCRBY', key, 'stock', -1)  
  
-- 添加用户到领券集合  
redis.call('SADD', userSetKey, userIdAndRowNum)  
  
-- 获取用户领券集合的长度  
local userSetLength = redis.call('SCARD', userSetKey)  
  
-- 返回结果  
return combineFields(true, userSetLength)
```
### 涉及到的 Redis 键设计
优惠券模板使用 Hash 结构存储，缓冲池使用 Set 结构存储，读取进度使用 String 存储。

### 批处理 Redis 和 数据库
消费者 B 收到批处理消息后，根据批次规模批量扣减数据优惠券模板。并根据扣减规模批量 pop 缓冲池用户信息，处理后批量插入用户领券记录表，最后利用 lua 脚本批量写入 Redis 用户领券记录。

```java
/*
批量扣减库存
*/
private Integer decrementCouponTemplateStock(CouponTemplateDistributionEvent event, Integer decrementStockSize) {  
    Long couponTemplateId = event.getCouponTemplateId();  
    int decremented = couponTemplateMapper.decrementCouponTemplateStock(event.getShopNumber(), couponTemplateId, decrementStockSize);  
    if (!SqlHelper.retBool(decremented)) {  
        LambdaQueryWrapper<CouponTemplateDO> queryWrapper = Wrappers.lambdaQuery(CouponTemplateDO.class).eq(CouponTemplateDO::getShopNumber, event.getShopNumber()).eq(CouponTemplateDO::getId, couponTemplateId);  
        CouponTemplateDO couponTemplateDO = couponTemplateMapper.selectOne(queryWrapper);  
        return decrementCouponTemplateStock(event, couponTemplateDO.getStock());  
    }  
    return decrementStockSize;  
}
```

```Java
/*
批量弹出缓冲池用户
*/
List<String> batchUserMaps = stringRedisTemplate.opsForSet().pop(batchUserSetKey, couponTemplateStock);
```

```Java
/**  
 * 批量保存用户优惠券记录，记录保存失败的记录，从用户优惠券集合中移除保存失败的元素。  
 */  
private void batchSaveUserCouponList(Long couponTemplateId, Long couponTaskBatchId, List<UserCouponDO> userCouponDOList) {  
    try {  
        log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号, 批量插入用户优惠券列表");  
        // 批量插入用户优惠券记录  
        userCouponMapper.insert(userCouponDOList, userCouponDOList.size());  
    } catch (Exception ex) {  
        Throwable cause = ex.getCause();  
        // 插入分发失败记录，从分发用户列表中移除触发异常的用户元素。  
        if (cause instanceof BatchExecutorException) {  
            log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号, 批量插入用户优惠券列表失败，降级为逐条插入");  
            // 添加到 t_coupon_task_fail 并标记错误原因，方便后续查看未成功发送的原因和记录  
            List<CouponTaskFailDO> couponTaskFailDOList = new ArrayList<>();  
            List<UserCouponDO> toRemove = new ArrayList<>();  
  
            // 批量插入失败，改为循环单记录插入。  
            userCouponDOList.forEach(each -> {  
                try {  
                    userCouponMapper.insert(each);  
                } catch (Exception ignored) {  
                    Boolean hasReceived = couponExecuteDistributionConsumer.hasUserReceivedCoupon(couponTemplateId, each.getUserId());  
                    if (hasReceived) {  
                        // 添加到 t_coupon_task_fail 并标记错误原因，方便后续查看未成功发送的原因和记录  
                        Map<Object, Object> objectMap = MapUtil.builder().put("rowNum", each.getRowNum()).put("cause", "用户已经有用该优惠券").build();  
                        CouponTaskFailDO couponTaskFailDO = CouponTaskFailDO.builder().batchId(couponTaskBatchId).jsonObject(com.alibaba.fastjson.JSON.toJSONString(objectMap)).build();  
                        couponTaskFailDOList.add(couponTaskFailDO);  
  
                        // 从 userCouponDOList 中删除已经存在的记录  
                        toRemove.add(each);  
                    }  
                }  
            });  
  
            // 批量新增 t_coupon_task_fail 表  
            couponTaskFailMapper.insert(couponTaskFailDOList, couponTaskFailDOList.size());  
  
            // 删除已经重复的内容  
            userCouponDOList.removeAll(toRemove);  
            // 捕获批量插入异常后采用逐条插入策略，直接退出方法，不需要抛出批量插入异常，否则导致数据不一致。  
            return;  
        }  
        // 其他异常直接回滚数据库。  
        throw ex;  
    }  
}
```

```Lua
-- 封装优惠券分发操作，传入用户 id 与 优惠券 id 对应集合，将优惠券逐一分发给用户。  
local userIds = cjson.decode(ARGV[1])  -- 用户 ID 集合，JSON 格式的字符串  
local couponIds = cjson.decode(ARGV[2])  -- 优惠券 ID 集合，JSON 格式的字符串  
local userIdPrefix = KEYS[1]  -- 用户 ID 前缀（从 KEYS 获取）  
local limitKeyPrefix = KEYS[2]  -- 用户优惠券模板限制前缀  
local couponTemplateId = KEYS[3]  -- 优惠券模板 IDlocal currentTime = tonumber(ARGV[3])  -- 获取当前 Unix 时间戳（毫秒）  
local couponTemplateValidEndTime = tonumber(ARGV[4])  -- 优惠券模板到期时间  
  
-- 遍历用户 ID 集合  
for i, userId in ipairs(userIds) do  
    local key = userIdPrefix .. userId  -- 拼接用户 ID 前缀和用户 ID    local couponId = couponIds[i]  -- 获取对应的优惠券 ID    if couponId then  
        redis.call('ZADD', key, currentTime, couponId)  -- 添加优惠券 ID 到 用户优惠券 ZSet        local limitKey = limitKeyPrefix .. userId .. '_' ..  couponTemplateId  
        redis.call('INCR', limitKey)  -- 添加用户和优惠券的领取次数，方便后续对用户进行领取次数前置限制  
        redis.call('EXPIRE', limitKey, couponTemplateValidEndTime)  -- 添加用户优惠券模板限制领取 Key 过期时间  
    end  
end
```

```Java
// 消费者 B 批处理操作

/**  
 * */@Component  
@RequiredArgsConstructor  
@RocketMQMessageListener(topic = "one-coupon_distribution-service_coupon-execute-distribution_topic${unique-name:}", consumerGroup = "one-coupon_distribution-service_coupon-execute-distribution_cg${unique-name:}")  
@Slf4j(topic = "CouponExecuteDistributionConsumer")  
public class CouponExecuteDistributionConsumer implements RocketMQListener<MessageWrapper<CouponTemplateDistributionEvent>> {  
  
    private final UserCouponMapper userCouponMapper;  
    private final CouponTemplateMapper couponTemplateMapper;  
    private final CouponTaskMapper couponTaskMapper;  
    private final CouponTaskFailMapper couponTaskFailMapper;  
    private final StringRedisTemplate stringRedisTemplate;  
  
    @Lazy  
    @Resource    private CouponExecuteDistributionConsumer couponExecuteDistributionConsumer;  
  
    private static final String BATCH_SAVE_USER_COUPON_LUA_PATH = "lua/batch_user_coupon_list.lua";  
    private final static int BATCH_USER_COUPON_SIZE = 5000;  
    private final String excelPath = Paths.get("").toAbsolutePath() + "/tmp";  
  
    /**  
     * 操作数据库，根据用户列表分发优惠券。  
     * 根据 Redis 分发用户缓冲区，批量扣减数据库优惠券库存，新增用户优惠券记录。  
     */  
    @Transactional(rollbackFor = Exception.class)  
    @Override  
    public void onMessage(MessageWrapper<CouponTemplateDistributionEvent> messageWrapper) {  
        // 开头打印日志，平常可 Debug 看任务参数，线上可报平安（比如消息是否消费，重新投递时获取参数等）  
        CouponTemplateDistributionEvent event = messageWrapper.getMessage();  
  
        String batchUserSetKey = String.format(DistributionRedisConstant.TEMPLATE_TASK_EXECUTE_BATCH_USER_KEY, event.getCouponTaskId());  
        Long batchUserIdsSize = stringRedisTemplate.opsForSet().size(batchUserSetKey);  
        if (batchUserIdsSize == null || batchUserIdsSize <= 0) {  
            log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号 - 执行消费逻辑失败，分发用户缓冲池为空，批处理 Id: {}，缓冲池 key: {}", event.getCouponTaskId(), batchUserSetKey);  
            return;  
        }  
  
        // 1. 处理缓冲池数量达到 5000 阈值消息  
        if (!event.getDistributionEndFlag()) {  
            log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号，处理[达到阈值]消息，消息体：{}", event);  
            decrementCouponTemplateStockAndSaveUserCouponList(event);  
            return;  
        }  
  
        // 2. 处理 excel 读取结束消息  
        log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号，处理 [excel 读取结束]消息，消息体：{}", event);  
        event.setBatchUserSetSize(batchUserIdsSize.intValue());  
        decrementCouponTemplateStockAndSaveUserCouponList(event);  
  
        // 2.1 分发用户缓冲池仍然有数据，优惠券库存不足。  
        List<String> batchUserMaps = stringRedisTemplate.opsForSet().pop(batchUserSetKey, Integer.MAX_VALUE);  
        if (CollUtil.isNotEmpty(batchUserMaps)) {  
            log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号, 用户缓冲池 {} 有剩余数据，优惠券 {} 库存不足。", batchUserSetKey, event.getCouponTemplateId());  
            // 添加到 t_coupon_task_fail 并标记错误原因，方便后续查看未成功发送的原因和记录  
            List<CouponTaskFailDO> couponTaskFailDOList = new ArrayList<>(batchUserMaps.size());  
            for (String batchUserMapStr : batchUserMaps) {  
                Map<Object, Object> objectMap = MapUtil.builder().put("rowNum", JSON.parseObject(batchUserMapStr).get("rowNum")).put("cause", "优惠券库存不足").build();  
                CouponTaskFailDO couponTaskFailDO = CouponTaskFailDO.builder().batchId(event.getCouponTaskBatchId()).jsonObject(com.alibaba.fastjson.JSON.toJSONString(objectMap)).build();  
                couponTaskFailDOList.add(couponTaskFailDO);  
            }  
            // 添加到 t_coupon_task_fail 并标记错误原因  
            couponTaskFailMapper.insert(couponTaskFailDOList);  
        }  
  
        // 2.2 生成分发失败用户的 excel。以 5000 为一批，查询分发失败用户集合，生成 excel。  
        long initId = 0;  
        String failFileAddress = excelPath + "/用户分发记录失败Excel-" + event.getCouponTaskBatchId() + ".xlsx";  
        ExcelWriter excelWriter = null;  
        WriteSheet writeSheet = null;  
        boolean hasWritten = false; // 标记是否写入过数据  
  
        try {  
            while (true) {  
                List<CouponTaskFailDO> couponTaskFailDOList = listUserCouponTaskFail(event.getCouponTaskBatchId(), initId);  
                if (CollUtil.isEmpty(couponTaskFailDOList)) {  
                    if (!hasWritten) {  
                        failFileAddress = null;  
                    }  
                    break;  
                }  
  
                // 第一次有数据时再初始化 writer 和 sheet                if (excelWriter == null) {  
                    excelWriter = EasyExcel.write(failFileAddress, UserCouponTaskFailExcelObject.class).build();  
                    writeSheet = EasyExcel.writerSheet("用户分发失败Sheet").build();  
                }  
  
                hasWritten = true;  
  
                List<UserCouponTaskFailExcelObject> excelDataList = couponTaskFailDOList.stream()  
                        .map(each -> JSONObject.parseObject(each.getJsonObject(), UserCouponTaskFailExcelObject.class))  
                        .toList();  
                excelWriter.write(excelDataList, writeSheet);  
  
                if (couponTaskFailDOList.size() < BATCH_USER_COUPON_SIZE) {  
                    break;  
                }  
  
                initId = couponTaskFailDOList.stream()  
                        .mapToLong(CouponTaskFailDO::getId)  
                        .max()  
                        .orElse(initId);  
            }  
        } finally {  
            if (excelWriter != null) {  
                excelWriter.finish(); // 注意关闭 writer            }  
        }  
  
  
        // 确保所有用户都已经接到优惠券后，设置优惠券推送任务完成时间  
        log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号，消息推送任务结束。");  
        CouponTaskDO couponTaskDO = CouponTaskDO.builder().failFileAddress(failFileAddress).id(event.getCouponTaskId()).status(CouponTaskStatusEnum.SUCCESS.getStatus()).completionTime(new Date()).build();  
        couponTaskMapper.updateById(couponTaskDO);  
    }  
  
    /**  
     * 遍历 Redis 分发用户缓冲池，将优惠券加到用户优惠券列表。  
     */  
    @SneakyThrows  
    private void decrementCouponTemplateStockAndSaveUserCouponList(CouponTemplateDistributionEvent event) {  
        // 1. 确保优惠券库存充足  
        Integer couponTemplateStock = decrementCouponTemplateStock(event, event.getBatchUserSetSize());  
        if (couponTemplateStock <= 0) {  
            return;  
        }  
  
        // 2. 操作数据库，获取 Redis 缓冲池分发用户记录，向数据库新增用户优惠券记录  
        String batchUserSetKey = String.format(DistributionRedisConstant.TEMPLATE_TASK_EXECUTE_BATCH_USER_KEY, event.getCouponTaskId());  
        List<String> batchUserMaps = stringRedisTemplate.opsForSet().pop(batchUserSetKey, couponTemplateStock);  
        if (CollUtil.isEmpty(batchUserMaps)) {  
            log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号，请求 Redis 分发用户缓冲池失败，回滚扣减的库存。");  
            // 请求 Redis 失败后，回滚数据库。  
            couponTemplateMapper.incrementCouponTemplateStock(event.getShopNumber(), event.getCouponTemplateId(), couponTemplateStock);  
            return;  
        }  
        List<UserCouponDO> userCouponDOList = new ArrayList<>(batchUserMaps.size());  
        Date now = new Date();  
        for (String each : batchUserMaps) {  
            JSONObject userIdAndRowNumJsonObject = JSON.parseObject(each);  
            DateTime validEndTime = DateUtil.offsetHour(now, JSON.parseObject(event.getCouponTemplateConsumeRule()).getInteger("validityPeriod"));  
            UserCouponDO userCouponDO = UserCouponDO.builder().id(IdUtil.getSnowflakeNextId()).couponTemplateId(event.getCouponTemplateId()).rowNum(userIdAndRowNumJsonObject.getInteger("rowNum")).userId(userIdAndRowNumJsonObject.getLong("userId")).receiveTime(now).receiveCount(1) // 代表第一次领取该优惠券  
                    .validStartTime(now).validEndTime(validEndTime).source(CouponSourceEnum.PLATFORM.getType()).status(CouponStatusEnum.EFFECTIVE.getType()).createTime(now).updateTime(now).delFlag(0).build();  
            userCouponDOList.add(userCouponDO);  
        }  
  
        // 批量保存优惠券用户记录，同时从 userCouponDOList 中移除无法分发的用户。  
        batchSaveUserCouponList(event.getCouponTemplateId(), event.getCouponTaskBatchId(), userCouponDOList);  
  
        // 3. 操作 Redis，执行 lua 脚本，批量新增优惠券记录到用户领券列表。  
        List<String> userIdList = userCouponDOList.stream().map(UserCouponDO::getUserId).map(String::valueOf).toList();  
        List<String> couponIdList = userCouponDOList.stream().map(each -> StrUtil.builder().append(event.getCouponTemplateId()).append("_").append(each.getId()).toString()).map(String::valueOf).toList();  
        String couponIdsJson = JSONUtil.toJsonStr(couponIdList);  
        String userIdsJson = JSONUtil.toJsonStr(userIdList);  
        List<String> keys = List.of(StrUtil.replace(EngineRedisConstant.USER_COUPON_TEMPLATE_LIST_KEY, "%s", ""), EngineRedisConstant.USER_COUPON_TEMPLATE_LIMIT_KEY, String.valueOf(event.getCouponTemplateId()));  
        List<String> args = Arrays.asList(  
                userIdsJson,  
                couponIdsJson,  
                String.valueOf(new Date().getTime()),  
                String.valueOf(  
                        // 取当前时间距离优惠券模板结束时间之间的秒数作为 Limit Key 的过期时间  
                        Duration.between(LocalDateTime.now(), event.getValidEndTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime()).getSeconds()  
                )  
        );  
        DefaultRedisScript<Void> buildLuaScript = Singleton.get(BATCH_SAVE_USER_COUPON_LUA_PATH, () -> {  
            DefaultRedisScript<Void> redisScript = new DefaultRedisScript<>();  
            redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(BATCH_SAVE_USER_COUPON_LUA_PATH)));  
            redisScript.setResultType(Void.class);  
            return redisScript;  
        });  
        stringRedisTemplate.execute(buildLuaScript, keys, args.toArray());  
  
        // 4. 当分发优惠券失败，需要将优惠券数量回滚，回滚的值即分发失败的用户的数量。  
        int originalUserCouponSize = batchUserMaps.size();  
        // 执行 batchSaveUserCouponList 后，userCouponDOList 中仅仅剩余成功分发用户。  
        int availableUserCouponSize = userCouponDOList.size();  
        int rollbackStock = originalUserCouponSize - availableUserCouponSize;  
        if (rollbackStock > 0) {  
            log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号, 分发失败优惠券数量：{}，开始执行回滚操作。Redis 优惠券模板键：{}；数据库优惠券模板 shopNumber = {}，couponTemplateId = {}",  
                    rollbackStock,  
                    String.format(  
                        EngineRedisConstant.COUPON_TEMPLATE_KEY, event.getCouponTemplateId()  
                    ),  
                    event.getShopNumber(),  
                    event.getCouponTemplateId()  
            );  
            // 回滚优惠券模板缓存库存数量  
            stringRedisTemplate.opsForHash().increment(String.format(EngineRedisConstant.COUPON_TEMPLATE_KEY, event.getCouponTemplateId()), "stock", rollbackStock);  
  
            // 回滚优惠券模板数据库库存数量  
            couponTemplateMapper.incrementCouponTemplateStock(event.getShopNumber(), event.getCouponTemplateId(), rollbackStock);  
        }  
    }  
  
    /**  
     * 递归扣减优惠券库存，获取准确的优惠券库存数量。  
     */  
    private Integer decrementCouponTemplateStock(CouponTemplateDistributionEvent event, Integer decrementStockSize) {  
        Long couponTemplateId = event.getCouponTemplateId();  
        int decremented = couponTemplateMapper.decrementCouponTemplateStock(event.getShopNumber(), couponTemplateId, decrementStockSize);  
        if (!SqlHelper.retBool(decremented)) {  
            LambdaQueryWrapper<CouponTemplateDO> queryWrapper = Wrappers.lambdaQuery(CouponTemplateDO.class).eq(CouponTemplateDO::getShopNumber, event.getShopNumber()).eq(CouponTemplateDO::getId, couponTemplateId);  
            CouponTemplateDO couponTemplateDO = couponTemplateMapper.selectOne(queryWrapper);  
            return decrementCouponTemplateStock(event, couponTemplateDO.getStock());  
        }  
        return decrementStockSize;  
    }  
  
    /**  
     * 批量保存用户优惠券记录，记录保存失败的记录，从用户优惠券集合中移除保存失败的元素。  
     */  
    private void batchSaveUserCouponList(Long couponTemplateId, Long couponTaskBatchId, List<UserCouponDO> userCouponDOList) {  
        try {  
            log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号, 批量插入用户优惠券列表");  
            // 批量插入用户优惠券记录  
            userCouponMapper.insert(userCouponDOList, userCouponDOList.size());  
        } catch (Exception ex) {  
            Throwable cause = ex.getCause();  
            // 插入分发失败记录，从分发用户列表中移除触发异常的用户元素。  
            if (cause instanceof BatchExecutorException) {  
                log.info("[消费者] 优惠券任务数据库执行推送@分发到用户账号, 批量插入用户优惠券列表失败，降级为逐条插入");  
                // 添加到 t_coupon_task_fail 并标记错误原因，方便后续查看未成功发送的原因和记录  
                List<CouponTaskFailDO> couponTaskFailDOList = new ArrayList<>();  
                List<UserCouponDO> toRemove = new ArrayList<>();  
  
                // 批量插入失败，改为循环单记录插入。  
                userCouponDOList.forEach(each -> {  
                    try {  
                        userCouponMapper.insert(each);  
                    } catch (Exception ignored) {  
                        Boolean hasReceived = couponExecuteDistributionConsumer.hasUserReceivedCoupon(couponTemplateId, each.getUserId());  
                        if (hasReceived) {  
                            // 添加到 t_coupon_task_fail 并标记错误原因，方便后续查看未成功发送的原因和记录  
                            Map<Object, Object> objectMap = MapUtil.builder().put("rowNum", each.getRowNum()).put("cause", "用户已经有用该优惠券").build();  
                            CouponTaskFailDO couponTaskFailDO = CouponTaskFailDO.builder().batchId(couponTaskBatchId).jsonObject(com.alibaba.fastjson.JSON.toJSONString(objectMap)).build();  
                            couponTaskFailDOList.add(couponTaskFailDO);  
  
                            // 从 userCouponDOList 中删除已经存在的记录  
                            toRemove.add(each);  
                        }  
                    }  
                });  
  
                // 批量新增 t_coupon_task_fail 表  
                couponTaskFailMapper.insert(couponTaskFailDOList, couponTaskFailDOList.size());  
  
                // 删除已经重复的内容  
                userCouponDOList.removeAll(toRemove);  
                // 捕获批量插入异常后采用逐条插入策略，直接退出方法，不需要抛出批量插入异常，否则导致数据不一致。  
                return;  
            }  
            // 其他异常直接回滚数据库。  
            throw ex;  
        }  
    }  
  
    /**  
     * 查询用户是否已经领取过优惠券  
     *  
     * @return 用户优惠券模板领取信息是否已存在  
     */  
    @Transactional(propagation = Propagation.NOT_SUPPORTED)  
    public Boolean hasUserReceivedCoupon(Long couponTemplateId, Long userId) {  
        LambdaQueryWrapper<UserCouponDO> queryWrapper = Wrappers.lambdaQuery(UserCouponDO.class).eq(UserCouponDO::getUserId, userId).eq(UserCouponDO::getCouponTemplateId, couponTemplateId);  
        return userCouponMapper.selectOne(queryWrapper) != null;  
    }  
  
    /**  
     * 查询用户分发任务失败记录，使用  
     *  
     * @param batchId 分发任务批次 ID  
     * @param maxId   上次读取最大 ID  
     * @return 用户分发任务失败记录集合  
     */  
    private List<CouponTaskFailDO> listUserCouponTaskFail(Long batchId, Long maxId) {  
        LambdaQueryWrapper<CouponTaskFailDO> queryWrapper = Wrappers.lambdaQuery(CouponTaskFailDO.class)  
                .eq(CouponTaskFailDO::getBatchId, batchId)  
                .gt(CouponTaskFailDO::getId, maxId)  
                .last("LIMIT " + BATCH_USER_COUPON_SIZE);  
        return couponTaskFailMapper.selectList(queryWrapper);  
    }  
}
```